- 1로 만들기 때도 그렇고, 배열 크기 N+1로 선언할 때마다 인덱스 오류나는 거 조심
  N+1로 선언하면 N이 내가 배열에 직접 값 집어넣어준 것보다 작을 때 (이번 경우에는  N이 2 이하일 때
  값 넣어주는 단계에서 오류남

- dp 문제는 일단 하나하나 직접 계산해보면서 점화식 찾아낼 것
  

< 문제 풀이 >
한칸씩 세 번 연속 갈 수 없다는 부분에서 조금 고민이 됐다.
유튜브 알고리즘 설명 영상에서 본 적이 있는 풀이라서 비슷하게 하면 되겠거니 했는데 저 부분이 변수가 됐음.
고민하다보니 어차피 경우의 수는 (1칸->2칸) 이동하거나 (2칸->1칸) 이동하는 수밖에 없다는 결론에 다다름.

현재 위치를 기준으로 한 칸 앞에서 왔을 경우, 그 전에는 두 칸 앞에서 이동했어야만 함.
이걸 처음엔 조건으로 처리를 해야 하나 해서 끙끙댔는데
그냥 단순하게 arr 배열에서 두 칸 앞까지 가져와주면 되는 거였다.