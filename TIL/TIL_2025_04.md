## 📅 April

**2025.04.01 화요일**
<details> 
<summary><b>✅ TO DO LIST</b></summary>

<h3>🌱 Spring  </h3>
인프런 김영한 스프링입문

- [X] 프로젝트 환경 설정

- [X] 스프링 웹 개발 기초

- [X] 회원 관리 예제 - 백엔드 개발

<h3>🧠 Algorithm </h3>

- [X] 다익스트라 연습

</details>

<details>
<summary>알고리즘 문제 풀이</summary>

<details>
<summary>BOJ1238. 파티</summary>

[코드](../APS/BOJ/BOJ1238_파티.java)

> - 아이디어
>   - 다익스트라 2개 써서 오는 거 가는 거 계산해주고 더한 값이 가장 큰 거 출력
> - 느낀점
>   - 골드3이라서 쫄았는데 그냥 평범한 다익스트라 문제였다...그래프 문제가 거의 골드라서 경험치 잘 오르는 게 약간 머쓱함

</details>

<details>
<summary>BOJ11725. 트리의 부모 찾기</summary>

[코드](../APS/BOJ/BOJ11725_트리의부모찾기.java)

> - 아이디어
>   - bfs로 내려가면서 부모 저장해줌
> - 느낀점
>   - 쉬운 듯

</details>

<details>
<summary>BOJ4673. 셀프 넘버</summary>

[코드](../APS/BOJ/BOJ4673_셀프넘버.java)

> - 메모
>   - 툭하면 까먹는 각 자리수 더하는 방법...

</details>

<details>
<summary>BOJ16234. 인구 이동</summary>

[코드](../APS/BOJ/BOJ16234_인구이동.java)

> - 아이디어
>   - 하루 인구이동 일어나는 거 구현해놓고, while true 로 돌리면서 인구이동이 일어나지 않으면 return 해주기
> - 느낀점
>   - 하루 인구이동까지는 구현하기 까다롭지 않았는데 날짜 넘기면서 꼬였음

</details>

</details>

<br>

**2025.04.02 수요일**
<details> 
<summary><b>✅ TO DO LIST</b></summary>

<h3>🌱 Spring  </h3>
인프런 김영한 스프링입문

- [X] 스프링 빈과 의존관계

- [X] 회원 관리 예제 - 웹 MVC 개발

</details>

<details>
<summary>알고리즘 문제 풀이</summary>

<details>
<summary>BOJ1068. 트리</summary>

[코드](../APS/BOJ/BOJ1068_트리.java)
> - 아이디어
>   - 그래프 다 만들어주고, 제거할 노드의 자식리스트 비워주고, 전체 훑으면서 제거할 노드를 자식으로 갖는 경우 그 리스트에서도 빼줌
>   - 리프노드인지는 flag 변수 써서 처리
>   - head를 제거하는 경우 처리
> - 느낀점
>   - visited 배열 안 써줘도 될 것 같은데 그냥 혹시나 중복되는 자식 있을까봐 써줌. 근데 트리의 정의 자체가 모든 노드는 하나의 부모만 가져야 한대....필요없었음.

</details>

</details>

<br>

**2025.04.03 목요일**
<details>
<summary><b>✅ TO DO LIST</b></summary>
<h3>🌱 Spring  </h3>
인프런 김영한 스프링입문

- [ ] 스프링 DB 접근 기술

</details>

<details>
<summary>알고리즘 문제 풀이</summary>

<details>
<summary>BOJ14940. 쉬운 최단거리</summary>

[코드](../APS/BOJ/BOJ14940_쉬운최단거리.java)
> - 느낀점
>   - 델타 범위 설정 잘못해서 틀림...(nx < N && ny < N)...

</details>

<details>
<summary>SWEA1970. 쉬운 거스름돈</summary>

[코드](../APS/SWEA/SWEA1970_쉬운거스름돈.java)

> - 아이디어
>   - 큰 돈부터 채워넣기
> - 느낀점
>   - 쉬웠다

</details>

<details>
<summary>BOJ18352. 특정 거리의 도시 찾기</summary>

[코드](../APS/BOJ/BOJ18352_특정거리의도시찾기_다익스트라.java)

> - 느낀점
>   - 다익스트라 안 까먹게 연습 겸 풀어봄
> - 메모
>   - pq에 넣을 때 최단거리로 갱신된 Edge로 안 넣으면 시간초과 남!

</details>

<details>
<summary>BOJ14938. 서강 그라운드</summary>

[코드](../APS/BOJ/BOJ14938_서강그라운드.java)
> - 아이디어
>   1. 각 노드를 시작점으로 하는 전체 노드의 최단 거리를 구하고
>   2. 그 중에서 시작점 아이템 + 거리가 r 이하인 애들 아이템 먹어주기
>   3. MaxItem 갱신
> - 느낀점
>   - 설계의 중요성...냅다 코드로 쓰려니까 헷갈렸는데 막상 단계를 나누니까 그렇게 어려울 건 없었다

</details>

</details>

<br>

**2025.04.04 금요일**
<details>
<summary><b>✅ TO DO LIST</b></summary>
<h3>🌱 Spring  </h3>
인프런 김영한 스프링입문

- [ ] 스프링 DB 접근 기술

</details>

<details>
<summary>알고리즘 문제 풀이</summary>

<details>
<summary>SWEA1949. 등산로 조성</summary>

[코드](../APS/SWEA/SWEA1949_등산로조성.java)
> - 아이디어
>   1. 가장 높은 봉우리 찾아서 시작 (여러 개일 수 있음)
>   2. 사방탐색해서 더 작으면 이동
>   3. 같거나 큰 곳을 만났으면 1부터 K까지 빼보고 계속 이동해봄
>   4. 최대 깊이 저장
> - 느낀점
>   - 큰 논리는 맞았는데 처음엔 maxDepth 테케마다 초기화 안 해줘서 꼬였고  
>   그 다음엔 visited 체크해줬다가 dfs 끝나면 푸는 거 깜빡해서 좀 헤맸다
> - 메모
>   - 중간 중간 논 시간 다 포함해서 2시간 좀 넘게 걸린 듯?

</details>

<details>
<summary>BOJ11660. 구간 합 구하기 5</summary>

[코드](../APS/BOJ/BOJ11660_구간합구하기5.java)
> - 아이디어
>   - 전체 map 행마다 구간합 배열 만들어놓고
>   - x1,y1 ~ x2,y2 에 속하는 네모 구간을 한 줄씩 내려가면서 행별 구간합 더해주기

</details>

</details>

<br>

**2025.04.05 토요일**
<details>
<summary><b>✅ TO DO LIST</b></summary>
<h3>🌱 Spring  </h3>
인프런 김영한 스프링입문

- [X] 스프링 DB 접근 기술

- [ ] AOP

</details>

<details>
<summary>알고리즘 문제 풀이</summary>

<details>
<summary>SWEA5656. 벽돌 깨기</summary>

[코드](../APS/SWEA/SWEA5656_벽돌깨기.java)

> - 아이디어
>   1. 구슬을 떨어뜨릴 열 고르기 (순열 dfs)
>   2. 떨어뜨린 칸을 기점으로 퍼지면서 깨뜨릴 수 있는 벽돌 다 깨뜨리기 (dfs / bfs)
>   3. 공중에 뜬 벽돌 끌어내려주기
>   4. 3 끝나고 바뀐 map으로 1~3번 단계 구슬 개수만큼 반복
> - 느낀점
>   - 가장 까다로웠던 부분은 갱신된 map을 어디까지 갖고 다니고 어디서 초기화해줘야 하는지 + 공중에 뜬 벽돌을 어떻게 끌어내려줄지
> - 메모
>   - chatGPT의 도움으로 풀었기 때문에 다시 봐야 함. 로직 혼자 떠올릴 수 있을 때까지 연습해볼 것

</details>

<details>
<summary>BOJ12101. 1,2,3 더하기 2</summary>

[코드](../APS/groupstudy/algorithm_study/BOJ12101_123더하기2.java)
> - 아이디어
>  - n은 11보다 작다. 최대 10 -> 전체 조합의 개수는 ? dp[n] = dp[n-3] + dp[n-2] + dp[n-1] -> dp[10] = 274개
>  - 1로만 다 더해도 res 배열 최대 10자리. 3의 10승 = 59049. 브루트포스 가능
>  - 조합마다 길이 다름 -> res 배열 arr 말고 list로 관리
>  - 1부터 3까지 넣어보면서 바로바로 합 구해주고, N보다 커지면 return;  
>   N 되면 cnt 올려줌 (N 만들 수 있는 가능한 조합 개수)  
>   cnt가 K가 되면 가능한 조합 중 K번째라는 뜻. 출력해주고 return;  
>   아니다 싶으면 이전 상태로 돌아가야 하므로  
>   `*sum* -= i;`  
>   `*res*.remove(*res*.size() - 1);` 
> - 느낀점
>   - 요즘 맨날 그래프 문제만 풀다 보니 순열조합 또 까먹었는지 시간을 엄청 썼다
>   - 함수 끝나면 다시 마지막으로 작업했던 거 빼서 돌려놓으면 백트래킹 된다는 걸 자꾸 놓침
>   - 백트래킹 연습 좀 해야지...

</details>

<details>
<summary>BOJ15988. 1,2,3 더하기 3</summary>

[코드](../APS/BOJ/BOJ15988_123더하기3.java)
> - 메모
>   - 자료형 쓰는 데서 또 꼬임. 숫자 커진다 싶으면 long 쓸 것


</details>

</details>