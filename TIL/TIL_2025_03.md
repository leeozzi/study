## 📅 Mar

**2025.03.01 토요일**

<details>
<summary>BOJ1325. 효율적인 해킹</summary>

[코드](../APS/groupstudy/algorithm_study/BOJ1325_효율적인해킹.java)
> **_BFS_**
>
> - 아이디어 :  
>   해당 숫자에서 시작했을 때 해킹할 수 있는 컴퓨터의 수를 bfs로 세어주자!
> - 느낀 점 :
>   - bfs dfs 개념은 아는데 여전히 구현할 때마다 생각이 정리가 잘 안 된다. 연습 많이 해야지
>   - 반례 사이트 없이 디버깅할 수 있을 만큼 되고 싶다
> - 메모 :
>   - arr[i]에 담긴 배열이 비어있을 경우 처리 안 해줘서 틀림.
>   - return 값이 같은 게 나오면 result pq에 추가하게 했으므로, pq에 여러개가 담긴 상황이 있을 수 있음. 그 상태에서 더 큰 return 나오면 clear로 아예 비우고 걔로 넣어줘야 하는데 pop만 해줘서 틀림.

```
package workingon;

import java.io._;
import java.util._;

public class BOJ1325\_효율적인해킹 {
static ArrayList<Integer>[] arr;
static boolean[] visited;
static Queue<Integer> queue = new LinkedList<>();

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        arr = new ArrayList[N+1];

        for (int i = 1; i <= N; i++) {
            arr[i] = new ArrayList<>();
        }

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int A = Integer.parseInt(st.nextToken());
            int B = Integer.parseInt(st.nextToken());

            arr[B].add(A);
        }

// System.out.println(Arrays.toString(arr));
int cnt = 0;
int max = 0;
PriorityQueue<Integer> pq = new PriorityQueue<>();
for(int i = 1 ; i <= N ; i++) {
// System.out.println("i = " + i + "일 때");
visited = new boolean[N+1];
if(!arr[i].isEmpty()) {
int res = bfs(i);
if (res > max) {
pq.clear();
pq.offer(i);
max = res;
// System.out.println("PQ : " + pq);
} else if (max == res) {
pq.offer(i);
// System.out.println("PQ : " + pq);
}
}
}

        while(!pq.isEmpty()) {
            System.out.print(pq.poll()+" ");
        }


    }

    public static int bfs(int start){
        queue.offer(start);
        visited[start] = true;
        int cnt = 0;

        while(!queue.isEmpty()) {

// System.out.println("현재 큐 : " + queue);
int cur = queue.poll();
cnt++;
for(int i = 0 ; i < arr[cur].size() ; i++) {
if(!visited[arr[cur].get(i)]) {
queue.offer(arr[cur].get(i));
F visited[arr[cur].get(i)] = true;
}
}
}

// System.out.println("cnt : " + cnt);
return cnt;
}
}
```
</details>

<details>
<summary>BOJ2164. 카드2</summary>

[코드](../APS/groupstudy/algorithm_study/BOJ2164_카드2.java)
> **_Queue_**
>
> - 너무 쉬웠다...보자마자 queue 떠올리고 코드 쓰는 것까지 3분컷 함. 

```
package groupstudy.algorithm_study;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class BOJ2164_카드2 {
    /**
     * 카드2
     * <a href="https://www.acmicpc.net/problem/2164">...</a>
     */

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Queue<Integer> queue = new LinkedList<>();
        for(int i = 1 ; i <= n ; i++){
            queue.offer(i);
        }
        while(queue.size() > 1){
            int remove = queue.poll();
            int move = queue.poll();
            queue.offer(move);
        }

        System.out.println(queue.poll());
    }
}

```
</details>

<details>
<summary>BOJ1181. 단어 정렬</summary>

[코드](../APS/BOJ/BOJ1181_단어정렬.java)
> 이것도 보자마자 pq 써야지 하고 Comparator 만들어서 풀었음. 한...10분컷 한 듯?

```
package BOJ;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.PriorityQueue;

public class BOJ1181_단어정렬 {
    /**
     * 단어 정렬
     * <a href="https://www.acmicpc.net/problem/1181">...</a>
     */
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        PriorityQueue<String> pq = new PriorityQueue<>(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                if(o1.length() != o2.length())
                    return o1.length()-o2.length();
                else
                    return o1.compareTo(o2);
            }
        });

        for(int i = 0 ; i < N ; i++) {
            String word = br.readLine();
            if(!pq.contains(word))
                pq.offer(word);
        }

        while(!pq.isEmpty()) {
            System.out.println(pq.poll());
        }
    }
}

```
</details>

<details>
<summary>BOJ2920. 음계</summary>

[코드1](../APS/BOJ/BOJ2920_음계_1.java)
[코드2](../APS/BOJ/BOJ2920_음계_2.java)
> - 처음에 엄청 야매로 풀었다... ㅋㅋ 1부터 8까지가 한 번씩 등장한다길래 그냥 String으로 바꿔서 비교해줌  
> - 너무 야매로 푼 게 양심에 찔려서 flag 쓴 정석 방법으로도 다시 풀었다
> - 난이도는 쉬웠음. flag 쓸 때 약간 오래 생각하긴 했지만? 그래도 20분 안에 끝냄

```
// String 값 비교
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        StringBuilder sb = new StringBuilder();
        for(int i= 0 ;i < 8 ; i++)
            sb.append(sc.next());

        if(String.valueOf(sb).equals("12345678"))
            System.out.println("ascending");
        else if(String.valueOf(sb).equals("87654321"))
            System.out.println("descending");
        else
            System.out.println("mixed");
    }
}
```
```

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] arr = new int[8];
        for (int i = 0; i < 8; i++) {
            arr[i] = sc.nextInt();
        }

        boolean flag = true;
        for (int i = 0; i < 8 - 1; i++) {
            if(arr[i] < arr[i+1]) {
                if(!flag) {
                    System.out.println("mixed");
                    return;
                }
                flag = true;
            } else if(arr[i] > arr[i+1]){
                if(i != 0 && flag){
                    System.out.println("mixed");
                    return;
                }
                flag = false;
            }
        }
        if(flag) {
            System.out.println("ascending");
        } else {
            System.out.println("descending");
        }
    }
}

```

</details>

<details>
<summary>BOJ10250. ACM 호텔</summary>

[코드](../APS/BOJ/BOJ10250_ACM호텔.java)
> - 이런 문제 있을 때마다 나머지 있는 경우랑 없는 경우랑 나눠서 계산해주는 게 깔끔하지 못한 것 같아서 GPT에 물어봄
> - 출력 포맷 일케 설정하면 됨 ! => floor + String.format("%02d", dis);
> - dis = (N - 1) / H + 1 로 계산하면 됨

```
package BOJ;

import java.util.*;

public class BOJ10250_ACM호텔 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();

        for (int t = 1; t <= T; t++) {
            int H = sc.nextInt();
            int W = sc.nextInt();
            int N = sc.nextInt();

            int dis;
            int floor;
            if (N % H == 0) {
                dis = N / H;
                floor = H;
            } else {
                dis = N / H + 1;
                floor = N % H;
            }

            if (dis >= 10)
                System.out.println(floor + "" + dis);
            else
                System.out.println(floor + "0" + dis);
        }

    }

}

```
</details>

<details>
<summary>BOJ1676. 팩토리얼 0의 개수</summary>

[코드](../APS/groupstudy/algorithm_study/BOJ1676_팩토리얼0의개수.java)
> - 아이디어 :  
>   - 0이 생기는 경우는 2와 5가 페어됐을 때 !  
>   - 근데 5까지 가면 페어될 2는 앞에 있을 수밖에 없음
>   - 따라서, 5의 개수가 중요하다!
> - 느낀 점 :
>   - 생각했던 것과 자꾸 다르게 나와서 어려웠다
> - 메모 :
>   - 5의 제곱수들은 5를 여러 번 포함하고 있다는 사실을 간과함

```
package BOJ;

import java.util.Scanner;

public class BOJ1676_팩토리얼0의개수 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int cnt = 0;
        for(int i = 5 ; i <= n ; i*=5 ) {
            cnt += n/i;
        }
        System.out.println(cnt);
    }
}
```

</details>

<details>
<summary>BOJ10989. 수 정렬하기3</summary>

[코드](../APS/BOJ/BOJ10989_수정렬하기3.java)
> - 아이디어 : 
>   - 그냥 pq 쓸까... -> 시간초과
>   - 그렇다면 LinkedList 쓰고 정렬... -> 메모리 초과
>   - 직접 정렬해주는 수밖에 없었음. 카운팅 정렬 사용.
> - 느낀 점 :
>   - 템플릿에만 의존하면 안 된다! 카운팅 정렬 시험 공부할 때 기억해둔 거 그대로 쓰려고 했는데,  
>   저만한 크기의 배열을 두 개 만드는 것도 메모리 낭비고...바로바로 StringBuilder에 저장해주면 되는 거였음
>   arr에 인덱스로 자리 찾아서 저장할 게 아니므로 누적합으로 구할 필요도 없음.

```
package BOJ;

import java.io.*;
import java.util.Arrays;

public class BOJ10989_수정렬하기3 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        int n = Integer.parseInt(br.readLine());
        int[] cnt = new int[10001];
        for(int i = 0 ; i < n ; i++) {
            cnt[Integer.parseInt(br.readLine())] ++;
        }

        for(int i = 0 ; i < 10001 ; i++) {
            while(cnt[i] > 0){
                sb.append(i).append("\n");
                cnt[i]--;
            }
        }

        System.out.println(sb);

    }
}

```

</details>

<br>

**2025.03.03 월요일**

<details>
<summary>SWEA2382. 미생물 격리</summary>

[코드](../APS/SWEA/SWEA2382_미생물격리.java)
> - 아이디어 : 
>   - 군집들은 클래스로 만들어서 관리해야겠다
>   한 시간 지날 때 해야하는 것
>   - 있던 곳을 비워준다
>   - 방향대로 이동한다  
>   / next의 행이나 열이 0이면 미생물 수 /= 2  
	/ next가 null인지 보고 (이미 미생물 군집이 있는지 보고)  
		// null이 아니면 ->   
			미생물 수 비교해서 큰 애 방향으로 설정  
			미생물 수 더해서 저장해주기
>
> - 느낀 점 :  
>   문제를 보고 해야하는 일들을 단계로 나눠서 정리하는 능력이 좀 는 게 느껴진다
>
> - 메모 :
>   - 동시에 같은 칸으로 가려는 경우를 처리해줄 때 나는 아예 sort() 해서 처리하기 편한 순서대로 집어넣어줬는데, HashMap<String, ArrayList<Microbiome>>으로 기록하는 방법도 있었다.
>   - 아래 구문을 삭제하면 답이 틀리게 나오길래 고민했는데 sort() 정렬해주는 위치 때문이었다! 처음에 약품구역 들어가서 num 반으로 깎고 나서 정렬해줬어야 했는데 list에 값을 넣을 때 정렬해줘서 이상한 거였음. 순서 바꿔주고 나니까 밑에 구문 지워도 잘 나온다. 첨에 아마 매번 정렬하느라 시간복잡도도 컸을 듯.  
>   ```
>   else {    // 새로 들어가려는 애가 더 커
>   cur.num += map[cur.nextR][cur.nextC].num;
>   map[cur.nextR][cur.nextC].num = 0;
>   map[cur.nextR][cur.nextC] = cur;
>   cur.r = cur.nextR;
>   cur.c = cur.nextC;
>   }
>   ```

```
package SWEA;

import java.io.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class SWEA2382_미생물격리 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());
        String[] str;
        for (int t = 1; t <= T; t++) {
            str = br.readLine().split(" ");
            int N = Integer.parseInt(str[0]);   // map 크기
            int M = Integer.parseInt(str[1]);   // 격리 시간
            int K = Integer.parseInt(str[2]);   // 미생물 군집의 개수
            List<Microbiome> list = new ArrayList<>();  // 미생물 군집 정보 관리
            Microbiome[][] map = new Microbiome[N][N];

            // 최초 미생물 군집 정보 등록
            for (int i = 0; i < K; i++) {
                str = br.readLine().split(" ");
                int r = Integer.parseInt(str[0]);
                int c = Integer.parseInt(str[1]);
                int num = Integer.parseInt(str[2]);
                int dir = Integer.parseInt(str[3]); // 1 상, 2 하, 3 좌, 4 우

                Microbiome m = new Microbiome(r, c, num, dir);
                list.add(m);
                map[r][c] = m;
            }

            while (M-- > 0) {


                for (int i = 0; i < list.size(); i++) {
                    Microbiome cur = list.get(i);

                    switch (cur.dir) {
                        case 1:
                            cur.nextR--;
                            break;
                        case 2:
                            cur.nextR++;
                            break;
                        case 3:
                            cur.nextC--;
                            break;
                        case 4:
                            cur.nextC++;
                            break;
                    }

                    // 테두리에 도착하면
                    if (cur.nextR == 0 || cur.nextC == 0 || cur.nextR == N - 1 || cur.nextC == N - 1) {
                        cur.num /= 2; // 미생물 수 반으로 깎아주고
                        // 방향 반대로 바꿔주기
                        if (cur.dir == 1 || cur.dir == 3) cur.dir++;
                        else cur.dir--;
                    }
                }
                Collections.sort(list, Comparator.reverseOrder());

                map = new Microbiome[N][N];
                for (int i = 0; i < list.size(); i++) {
                    Microbiome cur = list.get(i);
                    if (map[cur.nextR][cur.nextC] == null) {
                        map[cur.nextR][cur.nextC] = cur;
                        cur.r = cur.nextR;
                        cur.c = cur.nextC;
                    } else {
                        if (map[cur.nextR][cur.nextC].num > cur.num) {  // 이미 있는 애가 더 커
                            map[cur.nextR][cur.nextC].num += cur.num;
                            cur.num = 0;
                        }
                    }
                }
            }

            int res = 0;
            for (int i = 0; i < list.size(); i++) {
                res += list.get(i).num;
            }
            System.out.printf("#%d " + res + "\n", t);
        }
    }

    public static class Microbiome implements Comparable<Microbiome> {
        int r;
        int c;
        int nextR;
        int nextC;
        int num;
        int dir;

        public Microbiome(int r, int c, int num, int dir) {
            this.r = r;
            this.c = c;
            this.num = num;
            this.dir = dir;
            this.nextR = r;
            this.nextC = c;
        }

        @Override
        public String toString() {
            return num + "(" + dir + ")";
        }

        @Override
        public int compareTo(Microbiome o) {
            return this.num - o.num;
        }
    }
}

```

</details>

<details>
<summary>BOJ13023. ABCDE</summary>

[코드](../APS/BOJ/BOJ13023_ABCDE.java)
> - 아이디어 :
>   - DFS로 내려가면서 최대로 어디까지 내려갈 수 있는지 체크. 5명 이상 내려갈 수 있으면 1 출력
> - 느낀점 :
>   - 처음에는 모든 친구가 다 A-B-C-D-E 관계여야 한단는 건가? 했는데, 알고 보니 그런 관계인 사람이 5명 이상 있으면 되는 거였음
> - 메모 :
>   - 기본 DFS 양식으로 쓰되, 단계 카운팅하는 게 관건이었다. depth 만 return 해서 쓰자니 자꾸 꼬이길래 maxDepth 만들어서 최대깊이 저장해줬다.
>   - dfs 재귀 돌리고 나서 visited[friend]를 초기화 안 해줬더니, 더 나은 루트가 있음에도 백트래킹이 안 되는 문제 발생.  
>   방금 보고 나온 친구 초기화 해줘야 maxDepth 5명 안 됐을 때 다른 루트도 탐색해볼 수 있음

```
package BOJ;

import java.io.*;
import java.util.*;

public class BOJ13023_ABCDE {
    /**
     * ABCDE
     * <a href="https://www.acmicpc.net/problem/13023">...</a>
     */

    static HashMap<Integer, ArrayList<Integer>> hashmap;
    static boolean[] visited;
    static Stack<Integer> stack = new Stack<>();
    static int maxDepth;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        int N = Integer.parseInt(input[0]);   // 사람 수
        int M = Integer.parseInt(input[1]);   // 친구 관계(간선) 수
        hashmap = new HashMap<>();
        for (int i = 0; i < M; i++) {
            input = br.readLine().split(" ");
            int a = Integer.parseInt(input[0]);
            int b = Integer.parseInt(input[1]);

            if (!hashmap.containsKey(a))
                hashmap.put(a, new ArrayList<>());
            hashmap.get(a).add(b);

            if (!hashmap.containsKey(b))
                hashmap.put(b, new ArrayList<>());
            hashmap.get(b).add(a);
        }

        /// 관계 설정 끝

        for (int p : hashmap.keySet()) {
            visited = new boolean[N];
            maxDepth = 1;
            dfs(p, 1);
            if (maxDepth >= 5) {
                System.out.println(1);
                return;
            }
        }
        System.out.println(0);


    }

    public static void dfs(int cur, int depth) {
        maxDepth = Math.max(maxDepth, depth);

        if(maxDepth >= 5) {
            return;
        }

        stack.add(cur);
        visited[cur] = true;

        for (int friend : hashmap.get(stack.pop())) {
            if (!visited[friend]) {
                dfs(friend, depth + 1);
                visited[friend] = false;
            }
        }
    }
}

```

</details>

<details>
<summary>BOJ2751. 수 정렬하기 2</summary>

[코드](../../APS/BOJ/BOJ2752_수정렬하기2_2.java)
> - 느낀점 :  
> 	실버길래 이렇게 쉬울 순 없다는 생각에 오히려 꼬아서 생각한 듯.  
> 	그냥 Arrays.sort() 써도 되는 문제였다. 허무해...  
> 	시간초과는 로직이 아니라 BufferedReader랑 StringBuilder 써서 해결해야 하는 문제였어
> - 메모 :
>   - '이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다' << 이 조건 간과하고 양수만 처리해서 틀림
>   - 심지어 수는 중복되지 않는다는 조건도 있다...이게 왜 실버?;;

```
package BOJ;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class BOJ2751_수정렬하기2_2 {
    /** 수 정렬하기 2
     * <a href="https://www.acmicpc.net/problem/2751">...</a>
     */
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        int N = Integer.parseInt(br.readLine());
        int[] arr = new int[N];
        for(int i = 0 ; i < N ; i++) {
            int num = Integer.parseInt(br.readLine());
            arr[i] = num;
        }
        Arrays.sort(arr);

        for(int i = 0 ; i < N ; i++) {
            sb.append(arr[i] + "\n");
        }

        System.out.println(sb);
    }
}

```
</details>

<br>

**2025.03.04 화요일**

<details>
<summary>알고리즘 월말평가 - 지은이의 전화 걸기</summary>

[코드](../../ssafy/시험/0304 월말평가/Algo_서울_09_이언지/src/Test1_서울_09_이언지.java)
> - 느낀 점 :
>   - 쉬웠다...근데 오히려 너무 쉬워서 내가 너무 단순하게 풀었나 의심됐어

```
import java.util.*;


public class Test1_서울_09_이언지 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for(int t = 1 ; t <= T ; t++) {
			
			String str = sc.next();
			
			// 입력 받은 문자열을 한 글자씩 쪼개서 배열에 담아준다
			char[] arr = str.toCharArray();
			int res = 0;	// 다이얼 돌릴 때마다 걸린 시간 더해줄 결과 변수
			
			// char 배열을 훑으면서 글자에 해당하는 값을 res에 더해준다
			for(int i = 0 ; i < arr.length ; i++) {
				if(arr[i] >= 'A' && arr[i] <= 'C') {
					res += 3;
				} else if (arr[i] >= 'D' && arr[i] <= 'F') {
					res += 4;
				} else if (arr[i] >= 'G' && arr[i] <= 'I') {
					res += 5;
				} else if (arr[i] >= 'J' && arr[i] <= 'L') {
					res += 6;
				} else if (arr[i] >= 'M' && arr[i] <= 'O') {
					res += 7;
				} else if (arr[i] >= 'P' && arr[i] <= 'S') {
					res += 8;
				} else if (arr[i] >= 'T' && arr[i] <= 'V') {
					res += 9;
				} else if (arr[i] >= 'W' && arr[i] <= 'Z') {
					res += 10;
				}
			}
			
			// 양식에 맞춰서 출력
			System.out.printf("#%d %d\n", t, res);
		}
	}

}

```
</details>

<details>
<summary>알고리즘 월말평가 - 괄호 짝짓기 완성 (실패) </summary>

[코드](../../ssafy/시험/0304 월말평가/Algo_서울_09_이언지/src/Test2_서울_09_이언지.java)
> - 아이디어 :
>   - 괄호는...스택이지
> - 느낀 점 :
>   - 1했다 생각했는데 마지막에 0 붙는 경우가 있었어...  
>   stack에서 꺼낼 애가 hashmap의 key로 포함하지 않는 문자라면 닫는 괄호인데 짝은 없는 애니까 맞추기 불가능!' 이 부분에서  
>   닫는 괄호를 pop 하고 문자열 붙여줬어야 했는데 pop 안 해줘서 닫는 괄호랑 같이 나옴

```
// 수정한 버전
import java.util.*;

public class Test2_서울_09_이언지 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int T = sc.nextInt();
		for(int t = 1 ; t <= T ; t++) {
			StringBuilder sb = new StringBuilder();
			Stack<Character> stack = new Stack<>();
			String str = sc.next();
			sb.append("#").append(t).append(" "); // 테스트케이스마다 공통으로 출력돼야하는 양식

			
			// HashMap에 쌍 묶어서 관리해줄 것
			HashMap<Character, Character> hashmap = new HashMap<>();
			hashmap.put('(', ')');
			hashmap.put('{', '}');
			hashmap.put('[', ']');
			hashmap.put('<', '>');
			
			// 이 반복문 돌고 나면 이미 짝 맞는 애들은 다 지워지고 안 맞는 애들만 남음
			for(int i = 0 ;i < str.length() ; i++) {
				// stack이 비어있으면 무조건 넣어주고
				if(stack.isEmpty()) {
					stack.push(str.charAt(i));
				}
				
				// 만약 내가 여는 애면 그냥 넣어줘
				else if(hashmap.containsKey(str.charAt(i))) {
					stack.push(str.charAt(i));
				}
				
				// 만약 내가 닫는 애고, 짝이 맞는 애를 만나면 지워줘
				else if (hashmap.containsKey(stack.peek()) && str.charAt(i) == hashmap.get(stack.peek())) {
					stack.pop();
				}
			}
			
//			System.out.println(stack);
		
			// 만약 스택이 비었으면 이미 짝 다 맞는 애들
			if(stack.isEmpty()) {
				sb.append("1");
				System.out.println(sb);
				continue;
			}
			
			// 이제 짝 맞춰줄 거야
			while(!stack.isEmpty()) {

				char top = stack.peek();

				// 만약 stack에서 꺼낼 애가 여는 괄호라면 짝 맞는 닫는 괄호 붙여줘
				if(hashmap.containsKey(top)) {
					sb.append(hashmap.get(top));
					stack.pop();
				}

				// 만약 stack에서 꺼낼 애가 hashmap의 key로 포함하지 않는 문자라면
				// 닫는 괄호인데 짝은 없는 애니까 맞추기 불가능!
				else {
					stack.pop();
					sb.append("0");
					break;
				}
			}

			System.out.println(sb);
		}	// testcase
	}
}

```
</details>

<details>
<summary>알고리즘 월말평가 - 수영장 물결</summary>

[코드](../../ssafy/시험/0304 월말평가/Algo_서울_09_이언지/src/Test3_서울_09_이언지.java)
> - 아이디어 :
>   - 좌표마다 그냥 함수로 델타 탐색 빼서 돌린 담에 최댓값 찾고, 그 좌표마다의 최댓값 중 최댓값을 구해주면 되곘다.
> - 느낀 점 :
>   - 쉽다고 느끼긴 했는데 정답 맞았을지는 모르겠다.

```
import java.util.Scanner;

public class Test3_서울_09_이언지 {

	static int[][] board;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int T = sc.nextInt();

		for (int t = 1; t <= T; t++) {
			int N = sc.nextInt();
			board = new int[N][N];

			// 초기 에너지값 담아주기
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++) {
					board[i][j] = sc.nextInt();
				}
			}

			long res = 0;

			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++) {
					// 현재 위치에서 A 썼을 때, B 썼을 때, C 썼을 때 중 가장 큰 값 cnt에 담아주고
					long cnt = Math.max(board[i][j], Math.max(b(i, j), c(i, j)));
					// 전체 위치에서 가장 큰 값 res에 담아줌
					res = Math.max(cnt, res);
				}
			}

			System.out.printf("#%d %d\n", t, res);
		}
	}

	// B 장풍 쏜 경우
	public static int b(int i, int j) {
		// 현재 위치에서 B 장풍 썼을 때 결과 담아줄 변수
		int cnt = 0;

		// 방향 설정해줄 델타값
		int[] dx = { -1, -1, 0, 1, 1, 1, 0, -1 };
		int[] dy = { 0, 1, 1, 1, 0, -1, -1, -1 };

		// 델타값 돌면서 결과 더해주기
		for (int d = 0; d < 8; d++) {
			int nx = dx[d] + i;
			int ny = dy[d] + j;

			if (nx >= 0 && ny >= 0 && nx < board.length && ny < board.length) {
				cnt += board[nx][ny];
			}
		}
		
		return cnt;
	}
	
	public static long c(int i, int j) {
		// 현재 위치에서 C 장풍 썼을 때 결과 담아줄 변수
		long cnt = 0;

		// 방향 설정해줄 델타값
		int[] dx = { -2, -2, -2, -2, -2, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1};
		int[] dy = { -2, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2};

		// 델타값 돌면서 결과 더해주기
		for (int d = 0; d < 16; d++) {
			int nx = dx[d] + i;
			int ny = dy[d] + j;

			if (nx >= 0 && ny >= 0 && nx < board.length && ny < board.length) {
				cnt += board[nx][ny];
			}
		}
		
		return cnt;
	}

}

```
</details>

<details>
<summary>SW역량평가 A형 나무의 키 (실패)</summary>

[코드](../../ssafy/시험/0304 SW역량평가/Tree.java)
> - 아이디어 :
>   - 한놈씩 팬다...하나를 1 2 1 2 이렇게 계속 키워주다가 3 미만으로 남으면 다음 애로 넘어감
>   - 한 바퀴 돌고 나서 남은 애들 보면서 1이랑 2 짝지을 수 있으면 또 이틀 써서 짝지어주기
>   - 남은 애들 짝짓기까지 끝냈으면, 목표치까지 1 남은 애들 or 2 남은 애들만 남아있을 것
>   - 1 남은 애들만 남았으면, *2 해주고 첫날 하루 -1 해줌  
>   2 남은 애들만 남았으면, *2 해줌
> - 느낀점 :
>   - 테케 다 맞아서 혹시나 했는데 역시나. 반례 듣고 나서 뒤통수 맞은 기분이었다.....A형의 벽은 높구나ㅜ
> - 메모 : 
>     - 마의 1 4 4 5 를 통과하지 못함 ㅎㅎ 1 4 4 5 인 경우 [2] [0] [1] [0] 이렇게 4일 주면 되는데, 내 로직으로는 7일 나온다.

```
import java.util.*;

public class Tree {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int T = sc.nextInt();
		for (int t = 1; t <= T; t++) {
			int n = sc.nextInt();
			int max = 0;
			int[] arr = new int[n];
			for (int i = 0; i < n; i++) {
				arr[i] = sc.nextInt();
				max = Math.max(max, arr[i]);
			}

			for (int i = 0; i < n; i++) {
				arr[i] = max - arr[i];
			}

			int sum = 0;
			for (int i = 0; i < n; i++) {
				sum += arr[i] / 3 * 2;
				arr[i] = arr[i] % 3;
			}

			Arrays.sort(arr);
			int cnt1 = 0;
			int cnt2 = 0;

			for (int i = 0; i < arr.length; i++) {
				if (arr[i] == 1)
					cnt1++;
				else if (arr[i] == 2)
					cnt2++;
			}

			int mutual = Math.min(cnt1, cnt2);
			sum += mutual * 2;

			int start1 = -1;
			for (int i = 0; i < n; i++) {
				if (arr[i] == 1) {
					start1 = i;
					break;
				}
			}

			for (int i = 0; i < mutual; i++) {
				arr[start1 + i] = 0;
				cnt1--;
				arr[arr.length - 1 - i] = 0;
				cnt2--;
			}

			if (cnt2 == 0 && cnt1 > 0) {
				sum += cnt1 * 2-1;
			} else if (cnt1 == 0 && cnt2 > 0) {
				sum += 4 * (cnt2 / 3);
				cnt2 = cnt2 % 3;
				
				if (cnt2 == 1) {
					sum += 2;
				} else if (cnt2 == 2) {
					sum += 3;
				}
			}

			System.out.printf("#%d %d\n", t, sum);

		}
	}
}

```

</details>

<br>

**2025.03.05 수요일**

<details>
<summary>BOJ25918. 북극곰은 괄호를 찢어 (시간초과) </summary>

[코드1](../APS/workingon/BOJ25918_북극곰은괄호를찢어_시간초과.java)
[코드2](../APS/workingon/BOJ25918_북극곰은괄호를찢어_시간초과2.java)
> - 아이디어
>   - 처음에는 O나 X 찾을 때마다 문자열에서 replace로 삭제해주고, 문자열이 비거나 바꿀 게 없으면 끝내주는 방식 생각함 -> 시간초과
> 	- stack에 넣어주면서 O나 X 발견하면 처리해주고, 남은 애들로 다시 돌리면서 days 카운트 해주는 방식 -> 시간초과
> - 느낀점
>   - 내 방식대로는 O(N^2)! 최대 20만일 때 N^2 되면 400억. O(N)에 처리해줄 방법을 찾아야 한다.
>   - 결국 GPT에 물어봤기 때문에 일단 안 풀고 내버려뒀다. 나중에 까먹을 때쯤 다시 풀어봐야지.
> - 메모
>   - 문자열 replace는 원본 문자열을 바꾸는 게 아니라서, 바꾼 문자열을 저장할 거면 다시 변수에 할당해줘야 한다.

```
package workingon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class BOJ25918_북극곰은괄호를찢어_시간초과2 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb;
        int N = Integer.parseInt(br.readLine());
        String S = br.readLine();
        int days = 0;
        boolean flag = true;
        Stack<Character> stack = new Stack<>();

        while(flag) {
            days++;
            flag = false;
            for (int i = 0; i < S.length(); i++) {
                char cur = S.charAt(i);
                if (stack.isEmpty()) {
                    stack.push(cur);
                } else {
                    char before = stack.peek();

                    if ((before == '(' && cur == ')') || (before == ')' && cur == '(')) {
                        stack.pop();
                        stack.push('O');
//                        System.out.println(before + "랑 " + cur + "랑 만나서 사라짐");
                        flag = true;
                    } else {
                        stack.push(cur);
//                        System.out.println(stack);
                    }
                }
            }   // 이거 돌고 나오면 이번 회차에 짝 맞는 애들 O로 바꿔서 stack 넣어줬어

            sb = new StringBuilder();
            while(!stack.isEmpty()) {
                char cur = stack.pop();
                if(cur != 'O'){
                    sb.append(cur);
                }
            }

            S = sb.toString();

            if(S.isEmpty())
                break;
        }

        if(stack.isEmpty())
            System.out.println(days);
        else
            System.out.println(-1);

    }   // main
}   // class


```
</details>

<details>
<summary>BOJ2999. 비밀 이메일</summary>

[코드](../study/APS/BOJ/BOJ2999_비밀이메일.java)
> - 아이디어 :
>   1. N의 약수들 중에 두 개를 R과 C로 골라
>   2. 입력을 세로로 받아적은 다음
>	3. 가로로 읽으면 정답
> - 느낀점 : 
> 	- 처음에 주어진 암호 만드는 방법대로 하라는 게 아니라, 그렇게 만들어진 암호를 해독하라는 게 미션이었음
>   - 막 어렵진 않은데 배열에 세로로 넣어주는 부분에서 살짝 헷갈렸다.
>   - N이 작아서 이건 약수 다 구해줘도 괜찮았는데, N이 커지면 시간복잡도 터질 것 같다. 루트 해서 가까운 약수로 해줘야 하나.

```
package BOJ;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class BOJ2999_비밀이메일 {
    public static void main(String[] args) {
        // N의 약수들 중에 두 개를 R과 C로 골라
        // 입력을 세로로 받아적은 다음
        // 가로로 읽으면 정답

        Scanner sc = new Scanner(System.in);
        String str = sc.next();
        int N = str.length();

        // 일단 R이랑 C 골라줄게
        // 약수들 담아줄 리스트
        // 최대 100글자니까 그냥 돌려줘도 될 것 같은데?
        List<Integer> list = new ArrayList<>();
        for (int i = 1; i <= N; i++) {
            if (N % i == 0) list.add(i);
        }

//        System.out.println(list);

        int R = 0;
        if (list.size() % 2 == 0) {
            R = list.get(list.size() / 2 - 1);
        } else {
            R = list.get((list.size() + 1) / 2 - 1);
        }
        int C = N / R;

//        System.out.println(N);
//        System.out.println(R + " " + C);


        // 이제 세로로 받아적을 거야
        char[][] map = new char[R][C];
        StringBuilder sb = new StringBuilder();
        int idx = 0;
        for (int j = 0; j < C; j++) {
            for (int i = 0; i < R; i++) {
                map[i][j] = str.charAt(idx);
                idx++;
            }
        }

        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {
                sb.append(map[i][j]);
            }
        }

        System.out.println(sb);
    }
}

```

</details>

<details>
<summary>SWEA4012. 요리사</summary>

[코드](../APS/SWEA/SWEA4012_요리사.java)
> - 아이디어 :
>   1. 재료 조합을 짜고    ex) [식재료1, 식재료2], [식재료3, 식재료4]
>   2. 짠 조합 안에서 맛 총합 구하고 차이 구해줘. 최소 차이값 갱신.  
>   for(int i = 0 ; i < N/2 ; i++)  
>   for(int j = 0 ; j < N/2; j++)  
>      sum1 += map[com1[i]][com1[j]];  
>      sum2 += map[com2[i]][com2[j]];  
>      int diff = Math.abs(sum1 - sum2);  
>      min = Math.min(min, diff);
>   3. 더 이상 새로운 조합이 없으면 min 출력
> - 느낀점 :
>   - 재귀 어려워 ㅜ
>   - 이거 N 커지면 시간복잡도 엄청 클 것 같은데...

```
package SWEA;

import java.util.*;

public class SWEA4012_요리사 {
    /**
     * 요리사
     * <a href="https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeUtVakTMDFAVH">...</a>
     */

    static int[][] board;
    static boolean[] vis;
    static int N;   // 식재료 개수
    static int min;
    static List<Integer> combi1;
    static List<Integer> combi2;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int t = 1; t <= T; t++) {
            N = sc.nextInt();
            board = new int[N][N];
            vis = new boolean[N];
            combi1 = new ArrayList<>();
            combi2 = new ArrayList<>();
            min = Integer.MAX_VALUE;

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    board[i][j] = sc.nextInt();
                }
            }   /// 여기까지 입력받기

            for (int i = 0; i < N / 2; i++) {
                combi1.add(0);
            }

            combi(0, 0);
            System.out.printf("#%d %d\n", t, min);
        }   // testCase 끝
    }   // main 끝

    // 일단 식재료 뭐뭐 고를지부터 정하자
    public static void combi(int sidx, int idx) {
        if (sidx == N / 2) {
            // combi2 만들어줘
            combi2.clear();
            for(int i = 0 ; i < N ; i++) {
                combi2.add(i);
            }
            combi2.removeAll(combi1);

//            System.out.println(combi1);
//            System.out.println(combi2);

            int sum1 = 0;
            int sum2 = 0;
            for(int i = 0 ; i < N/2 ; i++) {
                for(int j = 0 ; j < N/2; j++) {
                    if(i != j) {
                        sum1 += board[combi1.get(i)][combi1.get(j)];
                        sum2 += board[combi2.get(i)][combi2.get(j)];
                    }
                }
            }

//            System.out.println("sum1 : " + sum1 + " sum2 : " + sum2);
            int diff = Math.abs(sum1 - sum2);
//            System.out.println("diff : " + diff);
            min = Math.min(min, diff);
            return;
        }
        if (idx == N) return;

        combi1.set(sidx, idx);
        combi(sidx + 1, idx + 1);
        combi(sidx, idx + 1);
    }
}   // class 끝

```
</details>

<details>
<summary>BOJ15655. N과 M (6)</summary>

[코드](../APS/groupstudy/algorithm_study/BOJ15655_N과M6.java)
>- 느낀점 :
>	- 요리사 풀고 나서 바로 푼 거라 조합 코드 연습 느낌
>	- 결과 배열 안 만들어주고 StringBuilder에 바로바로 담아주고 싶었는데 꼬여서 그냥 배열 담고 마지막에 순회해서 출력해줬다.

```
package groupstudy.algorithm_study;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class BOJ15655_N과M6 {
    /**
     * N과 M (6)
     * <a href="https://www.acmicpc.net/problem/15655">...</a>
     */

    static int n, m;
    static int[] arr;
    static int[] res;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        n = Integer.parseInt(input[0]);
        m = Integer.parseInt(input[1]);

        input = br.readLine().split(" ");
        arr = new int[input.length];
        res = new int[m];
        for (int i = 0; i < input.length; i++) {
            arr[i] = Integer.parseInt(input[i]);
        }

        Arrays.sort(arr);
        com(0, 0);
    }

    public static void com(int num, int depth) {

        if (depth == m) {
            for(int i = 0 ; i < m ; i++) {
                System.out.print(res[i] + " ");
            }
            System.out.println();
            return;
        }
        if (num == n) {
            return;
        }


        res[depth] = arr[num];
        com(num + 1, depth + 1);
        com(num + 1, depth);
    }
}

```
</details>