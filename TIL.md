# Feb 2025

**2025.02.09 일요일**
> ### BOJ 15647. N과 M (1)
> ***백트래킹, 재귀함수, DFS***  
> 함수 구조 설계하는 게 어려웠다.  
> 어찌어찌 풀었지만 나중에 다시 풀었을 때 할 수 있을지 모르겠다.  
> 재귀함수 돌아가는 과정 하나하나 따라가면서 작동원리는 이해했는데  
> 백지에서 다시 구조 생각해내라고 하면 못할 것 같음.  
> 코드 여러 번 더 봐야 할 것 같다.  

> ### BOJ 15647. N과 M (3)
> ***백트래킹, 재귀함수, DFS***  
> N과 M (1) 풀고 나서 풀어서 훨씬 쉬웠음

> ### DoublyLinkedList 구현하기
> ***이중연결리스트***  
> 재밌었다 ! 처음에는 ArrayList로 하는 건가 싶었는데  
> 생각해보니 그럴 거면 그냥 인덱스 쓰면 되는데 왜 굳이 구현하라고 하겠나 싶어서 오로지 Node 간의 관계만으로 구현하려고 고민했다.
> head부터 next로 하나씩 건너가면서 순회하는 코드 생각했을 때가 젤 재밌었음  
> 

<br>

**2025.02.11 화요일**
> ### SWEA 2001. 파리퇴치
> - for문 4번 중첩 너무 찝찝한데...  
> 👉 공식 배웠음 ! 연습해볼 것  
> `우하단 + 좌상단 - 우상단 - 좌하단`


<br>

**2025.02.12 수요일**
> ### SWEA 1216. 회문2  
> - **ISSUE 1**  
    처음에는
    회문 길이가 홀수인 경우와 짝수인 경우를 나눠서 생각하려고 했음.  
    홀수인 경우 나를 기준으로 양옆으로 뻗어나가면서 비교하고  
    짝수인 경우에는 괄호쌍 맞추기 문제처럼 연속된 문자 만나면 stack에서 비워주는 방식으로 하려고 생각했는데  
    알고보니 ABBACACBBB이런 식으로 한 줄 안에 회문이 두 개 이상 나오면 값이 유효하지 않아짐.    
> - **ISSUE 2**  
    세로 탐색은 그냥 i랑 j만 바꿔주면 된다고 생각했는데 
    지금 palindrome  함수 안에서 [i][j-len] ~ [i][j+len]로 가로로 뻗어나가면서 검사하게 만들어 놔서 제대로 작동 안 함… 따로 만들어줘야 했음
> - **ISSUE 3**  
>   홀수 길이 출력할 때 마지막에 len++ 해주고 나서 종료되는 걸 고려 못해서 len * 2 + 1이라고 생각했음

> ### SWEA 풍선껌  
> - 크게 어렵진 않았다… 본인까지 더해주는 걸 깜빡해서 약간 시간 썼지만 구상 자체는 쉬웠음  
> 다만 for문 중첩 너무 많아서 찜찜할 뿐
> - 터뜨리려는 풍선의 꽃가루 수를 변수로 담아주고 반복하면서 델타값이랑 곱해서 뻗어나가기  
> 델타값이랑 곱하는 부분이 keypoint라고 함 ! 


<br>

**2025.02.13 목요일**
> ### BOJ 9375. 패션왕 신해빈  
> ***HashMap***  
> -  getOrDefault(key, new value) 함수 쓰는 법을 배웠다 !  
> - 옷 이름은 저장하지 않고 개수만 value로 저장해서 쓰는 방법  
> - 입지 않는 경우의 수를 하나 더해서 그냥 순열 뽑아주는 방식은 전혀 생각 못했다...

> ### BOJ 9461. 파도반수열
> ***DP***
> - 규칙 찾느라 노가다 좀 했음
> - int 배열로 dp 저장해주니까 int가 표현할 수 있는 값을 벗어나서 long으로 바꿔줌  
> 근데 이걸 어떻게 문제 보면서 바로 int 쓸 지 long 쓸 지 파악할 수 있을까?

> ### SWEA 8931. 제로
> ***Stack***
> - stack 기본 중의 기본 중의 기본. 걍 바로 풀고 바로 맞았음.

> ### Stack 구현해보기  
> ***Stack***  
> 전에 DoublyLinkedList 구현했던 것보단 훨씬 간단했다  
> 근데 일반 배열로 구현하자니 남는 메모리가 너무 거슬려서  
> ArrayList로 써서 편하게 하긴 함...  
> 구현 자체보다는 제네릭 문법이 조금 헷갈려서 찾아봐가면서 했다  

<br>

**2025.02.14 금요일**  
> ### BOJ 11659. 구간 합 구하기 4  
> ***누적합***  
> - 처음에는 arr에 숫자 담아주고 i-1 부터 j-1까지 더해줬는데 당연히 시간초과. 사실 좀 예상했음.  
> - 누적합 쓰는 걸 생각 못하고 있었던 건 아니라서... 실패 뜨자마자 쓰고 통과

> ### SWEA 5356. 의석이의 세로로 말해요  
> ***배열순회***  
> - 이거 걍 열 우선 탐색 하면서 null 인 애들 패스해주면 되겠는데?
> - 쉬웠음... 배열 크기 최대값으로 맞춰주니까 편함

> ### SWEA 4613. 러시아 국기 같은 깃발      
> - 진심 어이 없는 데서 실수해서 계속 틀린 거였음…  
> red 세는 조건 시작지점을 endB로 해야 하는데 startB로 해가지고… 바본가 진짜;;  
> 어쩐지 논리는 아무리 생각해도 맞는데 답은 틀렸더라ㅠ  
> - 시간복잡도 가늠 안 됨………
> - cnts 배열 따로 만들어주는 걸 떠올린 게 진짜 뿌듯했다 !
> - 나는 파란색 범위를 시작이랑 끝 정하고 좁혀줬는데, 솔빈이 코드 보니까 파란색 범위 정하는 부분을 나랑 다르게 구현해놨음.  
> 다른 부분은 전체적으로 비슷하게 풀었길래 뿌듯했다.

```
for (int i=1;i<=n-2;i++) {
    int wSum = 0;
    for (int j=0;j<i;j++) {
        wSum+=m-cnt[j][0];
    }
    for (int j=i+1;j<=n-1;j++) {
        int bSum = 0;
        for (int k=i;k<j;k++) {
            bSum+=m-cnt[k][1];
        }
        int rSum = 0;
        for (int k=j;k<n;k++) {
            rSum+=m-cnt[k][2];
        }
        min = Math.min(min, wSum+bSum+rSum);
    }
}
```

<br>

**2025.02.15 토요일**  
> ### SWEA 5432. 쇠막대기 자르기  
> ***stack***  
> - 자를 때마다 sum += 현재 층수  
> 근데 ( 만나면 sum에 1 더해줘야 함. 이거 안 더해주면 * 기준 오른쪽만 더하는 꼴이 됨  
> - 사실 자르는 부분을 *로 바꿔주는 단계 없이 하나씩 빼면서 바로바로 처리해주는 게 더 좋긴 하지만 처음에 좀 복잡하게 생각했어서...안 헷갈리려고 이렇게 했음

> ### SWEA 1224. 계산기3  
> ***stack***  
> - 후위계산식으로 변환하는 게 너무 헷갈려... 이해가 영 안 되는 건 아닌데 만들자니 헷갈려서 공식처럼 외워서 이해하는 게 나을 것 같음

> ### 정렬 연습
> ***SelectionSort, QuickSort, MergeSort***  
> - 갑자기 정렬 알고리즘에 꽂혀서 정렬 공부 ㅎ 생각보다 정렬 알고리즘 종류가 엄청엄청 많아서 놀랐다. 너무 많아서 뭐가 뭔지 헷갈려..
> - 영상 따라가면 이해는 되는데 구현하라고 하면 못할 것 같음. 기회 될 때 구현 연습도 해보고 싶다.

<br>

**2025.02.16 일요일**  
> ### BOJ11726. 2xN 타일링  
> ***DP***  
> - 사실 이거 예전에 싸피 비전공자 CT 시험 대비할 때 본 적 있는 문제라서 점화식을 알고는 있었는데  
> 납득이 잘 안 돼서 나름대로 처음부터 풀어보려고 했음.  
> f(n-2)에 두 칸짜리 타일을 더하는 경우 & f(n-1)에 한 칸짜리 타일을 더하는 경우로 나누어진다는 건 알았는데  
> 타일을 더할 때 앞에 더할지, 중간에 더할지, 뒤에 더할지 또 나뉘는 게 아닌가? 라는 생각이 자꾸 들었다. 괜한 호승심 ㅜ  
> 근데 혼자 처음부터 설계하다가 꼬여서 그냥 기존에 알고 있던 공식을 증명하는 방식으로 틀었더니 납득이 됐다.  
> 그려보니까 어차피 f(n-2)랑 f(n-1) 단계에서 그 경우의 수들을 다 포함하면서 올라오는 거였음. 허무해...ㅋㅋㅋ   
> - 근데 이거 직접 해보면서 잘못된 공식을 세운 덕분에 Math.pow(num, power) 함수를 알게됐다. 그럼그렇지 제곱 함수가 없을 리가 없어.

> ### SWEA21936. 길이가 M인 회문 찾기
> ***탐색***
> - 난이도가 D1이길래 만만하게 보고 풀었다가 생각보다 좀 꼬였다. 푸는 데 1시간 정도 걸린 듯?  
> 매번 난이도 쉬운 문제마다 이러는 것 같다.
> 접근법을 모르겠다거나 어려운 건 아닌데, 더 고급지게 풀고 싶다는 욕심에 단순한 답을 두고 어렵게 고민하는 경향이 있다.  
> 안 좋은 버릇...고쳐야지. 난이도만 보고 만만하게 보지 말 것 !


> ### SWEA12712. 파리잡기3
> ***2차원배열 탐색***
> - 사전학습 때 풀어본 문제기도 하고 워낙 많이 해본 종류의 문제다 보니 설계는 진짜 금방 했는데 자꾸 값이 틀리게 나와서 당황했다.  
> 알고보니 곱하기 모양 델타값을 잘못 설정해줌......  
> 이런 사소한 실수들 언제쯤 줄어들까ㅠ


> ### SWEA11315. 오목판정
> ***2차원배열 탐색***
> - 반복문이 많아지면 일단 머리가 아프다. 아이디어만 떠올리면 구현 자체는 간단한 게 좋아. 일단 앞에 indent 가 늘어나면 모든 게 귀찮아진다... 집중해서 꼼꼼하게 쓰는 연습을 해야 하는데... 특히나 이런 문제는 또 크게 어렵진 않은데 내가 유독 귀찮아하는 문제라 더더욱 집중력을 자꾸 잃는 것 같다.

<br>

**2025.02.16 일요일**  
> ### SWEA6485. 삼성시의 버스 노선
> - 입력 받을 게 많아서 문제 이해하는 게 오래 걸려서 그렇지 푸는 것 자체는 어렵지 않았음
> - 문제가 너무 읽기 귀찮아서 일단 냅다 입력 받을 것부터 입력 받고 시작했더니 훨씬 빠르게 이해가 됐다

> ### SWEA7102. 준홍이의 카드놀이
> - 오늘 시험도 그렇고 버스 노선도 그렇고...자꾸 카운트만 쓰는 기분인데....메모리가 낭비되고 있는 듯한 찜찜함.....
> - 솔빈이 코드 설명 들었는데 솔빈이는 가장 자주 등장하는 숫자를 수학적 규칙으로 찾아내서 풀었다. 훨씬 간단하고 좋아서 나도 저렇게 풀고 싶어  
> (=> N까지의 숫자와 M까지의 숫자를 더해서 나올 수 있는 조합 중 가장 많이 등장하는 값은 N+1부터 M+1까지)
```
    // 솔빈이 풀이
    int min = Math.min(n, m);
    int max = Math.max(n, m);
    for (int i = min + 1; i <= max + 1; i++) {
       sb.append(" ").append(i);    
    }
```

> ### SWEA6190. 정곤이의 단조 증가하는 수
> - 문제 제대로 읽을 것 ㅠㅠ 단조 증가하는 수가 없다면 -1을 출력한다는 부분 못 봐서 한 번 틀렸다
> - String으로 변환해서 각 자리수 char 로 비교해서 푼 거 좀 잘한 듯!!

> ### SWEA3499. 퍼펙트 셔플
> - 쉽게 풀기는 했는데 뭔가 너무 단순하게 푼 것 같아서 이래도 되나 싶음

> ### SWEA1989. 초심자의 회문 검사
> - for문에 이름 붙여서 제어해줄 수 있다는 걸 알고는 있었는데 써 본 적은 없다가, 아까 솔빈이가 쓴 거 보고 써봤다. 확실히 훨씬 편한 듯 !  
> 오목판정 풀 때도 그냥 얌전히 썼으면 조금은 더 쉽게 풀었을 것 같은데 괜히 오기부려서 오래 풀었나봐