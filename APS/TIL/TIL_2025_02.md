
## 📅 Feb

**2025.02.09 일요일**

<details>
<summary>BOJ15647. N과 M (1)</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_study/BOJ15649_N%EA%B3%BCM1.java)
> **_백트래킹, 재귀함수, DFS_**  
> 함수 구조 설계하는 게 어려웠다.  
> 어찌어찌 풀었지만 나중에 다시 풀었을 때 할 수 있을지 모르겠다.  
> 재귀함수 돌아가는 과정 하나하나 따라가면서 작동원리는 이해했는데  
> 백지에서 다시 구조 생각해내라고 하면 못할 것 같음.  
> 코드 여러 번 더 봐야 할 것 같다.

```
package groupstudy.algorithm_study;

import java.util.*;

public class BOJ15649_N과M1 {
    /**
     * N과 M (1)
     * <a href="https://www.acmicpc.net/problem/15649">...</a>
     */

    static int[] arr;
    static int[] visited;
    static int[] combi;

    static StringBuilder sb;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sb = new StringBuilder();

        int n = sc.nextInt();
        int m = sc.nextInt();
        arr = new int[n];
        visited = new int[n];
        combi = new int[m];

        for (int i = 0; i < n; i++) {
            arr[i] = i + 1;
        }

        dfs(n, m, 0);

        System.out.println(sb);
    }

    public static void dfs(int n, int m, int depth) {

        if (depth == m) {
            for (int e : combi) {
                sb.append(e + " ");
            }
            sb.append("\n");

            return;
        }

        for (int i = 0; i < n; i++) {
            if (visited[i] != 1) {
                combi[depth] = arr[i];
                visited[i] = 1;
                dfs(n, m, depth + 1);
                visited[i] = 0;
            }

        }

    }


}
```

</details>

<details>
<summary>BOJ15647. N과 M (3)</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_study/BOJ15651_N%EA%B3%BCM3.java)
> **_백트래킹, 재귀함수, DFS_**  
> N과 M (1) 풀고 나서 풀어서 훨씬 쉬웠음

```
package groupstudy.algorithm_study;

import java.util.Scanner;

public class BOJ15651_N과M3 {
    /**
     * N과 M (3)
     * <a href="https://www.acmicpc.net/problem/15651">...</a>
     */

    static int[] arr;
    static StringBuilder sb;
    static int[] com;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sb = new StringBuilder();

        int n = sc.nextInt();
        int m = sc.nextInt();

        arr = new int[n];
        com = new int[m];

        for (int i = 0; i < n; i++) {
            arr[i] = i + 1;
        }

        dfs(n, m, 0);

        System.out.println(sb);
    }

    public static void dfs(int n, int m, int depth) {

        if (depth == m) {
            for (int i = 0; i < m; i++) {
                sb.append(com[i]).append(" ");
            }
            sb.append("\n");

            return;
        }

        for (int i = 0; i < n; i++) {
            com[depth] = arr[i];
            dfs(n, m, depth + 1);
        }

    }

}

```

</details>

<details>
<summary>DoublyLinkedList 구현하기</summary>

[코드](https://github.com/leeozzi/study/tree/master/APS/groupstudy/algorithm_study/doublyLinkedList)
> **_이중연결리스트_**  
> 재밌었다 ! 처음에는 ArrayList로 하는 건가 싶었는데  
> 생각해보니 그럴 거면 그냥 인덱스 쓰면 되는데 왜 굳이 구현하라고 하겠나 싶어서 오로지 Node 간의 관계만으로 구현하려고 고민했다.
> head부터 next로 하나씩 건너가면서 순회하는 코드 생각했을 때가 젤 재밌었음

```
package groupstudy.algorithm_study.doublyLinkedList;

import java.util.ArrayList;
import java.util.List;

public class DoublyLinkedList implements ILinkedList {

    // 수인이 의견. add 할 때 추가하려는 위치까지 가는 걸 앞에서부터 갈지 뒤에서부터 갈지 정해주는 로직 있으면 좋겠다

    Node head;
    Node tail;
    int size = 0;

    @Override
    public void add(int index, Node node) {
        if (size == 0) {
            head = node;
            tail = node;
            head.prev = tail;
            tail.next = head;
            size++;
        } else {

            if (index != 0 && index != size) {
                Node cur = head;
                while (index-- > 0) {
                    // head에서부터 index 만큼 이동
                    Node next = cur.next;
                    cur = next;
                }

                Node temp = cur;    // 원래 index 위치에 있던 old node 따로 저장해두고

                // index-1 위치에 있는 node랑 연결해주기
                temp.prev.next = node;
                node.prev = temp.prev;

                // 아까 빼뒀던 old node랑 연결해주기
                temp.prev = node;
                node.next = temp;

                // node 추가됐으니까 size 키워주기
                size++;
            } else if (index == 0) {
                Node temp = head;
                head = node;

                temp.prev = node;
                node.next = temp;

                node.prev = tail;
                tail.next = node;

                size++;

            } else if (index == size) {
                Node temp = tail;
                tail = node;

                temp.next = node;
                node.prev = temp;

                node.next = head;
                head.prev = node;

                size++;

            }
        }

    }


    @Override
    public void remove(int value) {
        Node cur = head;

        // 하나씩 이동하면서 value 같은 애 만나면 내 전에 애랑 내 뒤에 애랑 이어주고 나는 빠지기
        for (int i = 0; i < size; i++) {
            if (cur.value == value) {
                cur.prev.next = cur.next;
                cur.next.prev = cur.prev;

                size--;
                return;
            }
            Node next = cur.next;
            cur = next;
        }
    }

    @Override
    public void printAll() {
        Node cur = head;
        for (int i = 0; i < size; i++) {
            System.out.print(cur + "\Main");

            Node next = cur.next;
            cur = next;
        }
    }
}
```

```
package groupstudy.algorithm_study.doublyLinkedList;

public class Node {
    int value;
    Node prev;
    Node next;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return value + "";
    }
}
```

</details>

<br>

**2025.02.11 화요일**

<details>
<summary> SWEA2001. 파리퇴치 </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA12712_%ED%8C%8C%EB%A6%AC%ED%87%B4%EC%B9%983.java)

> - for문 4번 중첩 너무 찝찝한데...  
>   👉 공식 배웠음 ! 연습해볼 것  
>   `우하단 + 좌상단 - 우상단 - 좌하단`

```
package SWEA;

import java.util.Scanner;

public class SWEA12712_파리퇴치3 {
    /**
     * 파리퇴치3
     * <a href="https://swexpertacademy.com/main/code/userProblem/userProblemDetail.do?contestProbId=AXuARWAqDkQDFARa">...</a>
     */

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();

        for (int Main = 1; Main <= T; Main++) {
            int N = sc.nextInt();
            int M = sc.nextInt();
            int[][] map = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    map[i][j] = sc.nextInt();
                }
            }

//            for(int i= 0 ; i < N ; i++) {
//                for(int j = 0 ; j < N ; j++) {
//                    System.out.print(map[i][j] + " ");
//                }
//                System.out.println();
//            }

            int max = 0;

            int[] dx1 = {-1, 0, 1, 0};
            int[] dy1 = {0, 1, 0, -1};

            int[] dx2 = {-1, -1, 1, 1};
            int[] dy2 = {-1, 1, -1, 1};

            // 한 위치에서 +, x 둘 다 검사해야 함
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
//                    System.out.println("현재 위치 : (" + i + "," + j + ")");
                    // + 검사
                    int plussum = map[i][j];
                    for (int m = 1; m < M; m++) {
                        for (int d = 0; d < 4; d++) {
                            int nx = i + dx1[d] * m;
                            int ny = j + dy1[d] * m;

                            if (nx >= 0 && ny >= 0 && nx < N && ny < N) {
//                                System.out.print(map[nx][ny] + " ");
                                plussum += map[nx][ny];
//                                System.out.println("현재 plussum : " + plussum);
                            }
                        }
//                        System.out.println();

                    }

                    // x 검사
                    int xsum = map[i][j];
                    for (int m = 1; m < M; m++) {
                        for (int d = 0; d < 4; d++) {
                            int nx = i + dx2[d] * m;
                            int ny = j + dy2[d] * m;

                            if (nx >= 0 && ny >= 0 && nx < N && ny < N) {
                                xsum += map[nx][ny];
                            }

                        }
                    }

                    // 두 개 중 더 큰 값 비교
//                    System.out.println("현재 위치 : (" + i + "," + j + ")");
//                    System.out.println("xsum : " + xsum + " plussum : " + plussum);
                    max = Math.max(max, Math.max(xsum, plussum));
                }

            }

            System.out.println("#" + Main + " " + max);
        }
    }
}

```

</details>

<details>
<summary>배열 90도 돌리기 공식 (외울 것 !!!)</summary>

`newArr[j][n - i - 1] = arr[i][j]`

</details>

<br>

**2025.02.12 수요일**

<details>
<summary> SWEA1216. 회문2 </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA1216_%ED%9A%8C%EB%AC%B82.java)

> - **ISSUE 1**

    처음에는
    회문 길이가 홀수인 경우와 짝수인 경우를 나눠서 생각하려고 했음.
    홀수인 경우 나를 기준으로 양옆으로 뻗어나가면서 비교하고
    짝수인 경우에는 괄호쌍 맞추기 문제처럼 연속된 문자 만나면 stack에서 비워주는 방식으로 하려고 생각했는데
    알고보니 ABBACACBBB이런 식으로 한 줄 안에 회문이 두 개 이상 나오면 값이 유효하지 않아짐.

> - **ISSUE 2**

    세로 탐색은 그냥 i랑 j만 바꿔주면 된다고 생각했는데
    지금 palindrome  함수 안에서 [i][j-len] ~ [i][j+len]로 가로로 뻗어나가면서 검사하게 만들어 놔서 제대로 작동 안 함… 따로 만들어줘야 했음

> - **ISSUE 3**  
>   홀수 길이 출력할 때 마지막에 len++ 해주고 나서 종료되는 걸 고려 못해서 len \* 2 + 1이라고 생각했음

```
import java.util.Scanner;
public class SWEA1216_회문2 {

    static char[][] board;
    static int max;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        for (int Main = 0; Main < 10; Main++) {
            int tc = sc.nextInt();

            // board 만들기
            board = new char[100][100];


            for (int i = 0; i < 100; i++) {
                String line = sc.next();
                for (int j = 0; j < 100; j++) {
                    board[i][j] = line.charAt(j);
                }
            }

            max = 0;
            for (int i = 0; i < 100; i++) {
                for (int j = 0; j < 100; j++) {
                    palindrome(i, j);
                }
            }

            System.out.println("#" + tc + " " + max);

        }

    }

    public static void palindrome(int i, int j) {
        // 홀수 길이의 회문일 때
        int len = 1;
        while (j - len >= 0 && j + len < board[0].length) {
            if (board[i][j - len] == board[i][j + len]) {
                len++;
            } else {
                break;
            }
        }
        max = Math.max(len * 2 - 1, max);

        // 짝수 길이의 회문일 때
        len = 0;
        while (j - len >= 0 && j + len + 1 < board[0].length) {
            if (board[i][j - len] == board[i][j + 1 + len]) {
                len++;
            } else {
                break;
            }
        }
        max = Math.max(len * 2, max);

        // 세로 방향 회문 검사
        // 홀수일 때
        len = 1;
        while (i - len >= 0 && i + len < board.length) {
            if (board[i - len][j] == board[i + len][j]) {
                len++;
            } else {
                break;
            }
        }
        max = Math.max(len * 2 - 1, max);

        // 짝수일 때
        len = 0;
        while (i - len >= 0 && i + len + 1 < board.length) {
            if (board[i - len][j] == board[i + 1 + len][j]) {
                len++;
            } else {
                break;
            }
        }
        max = Math.max(len * 2, max);
    }

}

```

</details>

<details>
<summary>SWEA9490. 풍선팡</summary>

> - 크게 어렵진 않았다… 본인까지 더해주는 걸 깜빡해서 약간 시간 썼지만 구상 자체는 쉬웠음  
>   다만 for문 중첩 너무 많아서 찜찜할 뿐
> - 터뜨리려는 풍선의 꽃가루 수를 변수로 담아주고 반복하면서 델타값이랑 곱해서 뻗어나가기  
>   델타값이랑 곱하는 부분이 keypoint라고 함 !

```
import java.util.Scanner;

public class Balloon {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int T = sc.nextInt();

		for (int Main = 1; Main <= T; Main++) {
			int N = sc.nextInt();
			int M = sc.nextInt();

			int[][] arr = new int[N][M];
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < M; j++) {
					arr[i][j] = sc.nextInt();
				}
			}

			int[] dx = { -1, 0, 1, 0 };
			int[] dy = { 0, 1, 0, -1 };

			int max = 0;

			for (int i = 0; i < N; i++) {
				for (int j = 0; j < M; j++) {
					int num = arr[i][j];
					int sum = arr[i][j];

					for (int n = 1 ; n <= num ; n++) {
						for (int d = 0; d < 4; d++) {
							int nx = i + dx[d]*n;
							int ny = j + dy[d]*n;

							if (nx >= 0 && nx < N && ny >= 0 && ny < M) {
								sum += arr[nx][ny];
							}

						}

					}
					max = Math.max(max, sum);
				}

			}

			System.out.println("#" + Main + " " + max);
		}

	}
}

```

</details>

<br>

**2025.02.13 목요일**

<details> 
<summary>BOJ9375. 패션왕 신해빈</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_lunchStudy/BOJ9375_%ED%8C%A8%EC%85%98%EC%99%95%EC%8B%A0%ED%95%B4%EB%B9%88.java)
> **_HashMap_**
>
> - getOrDefault(key, new value) 함수 쓰는 법을 배웠다 !
> - 옷 이름은 저장하지 않고 개수만 value로 저장해서 쓰는 방법
> - 입지 않는 경우의 수를 하나 더해서 그냥 순열 뽑아주는 방식은 전혀 생각 못했다...

```
package groupstudy.algorithm_lunchStudy;

import java.io.*;
import java.util.*;

public class BOJ9375_패션왕신해빈 {
    /**
     * 패션왕 신해빈
     * <a href="https://www.acmicpc.net/problem/9375">...</a>
     */

    /*
    chatGPT한테 힌트 받은 부분
    - value를 name 말고 개수로 받아라
    - 안 입는 경우를 포함해서 곱하면 된다!
    */

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());

        for (int Main = 1; Main <= T; Main++) {
            int n = Integer.parseInt(br.readLine());

            // hashmap 만들어주기
//            Map<String, ArrayList<String>> hashmap = new HashMap<>();
            Map<String, Integer> hashmap = new HashMap<>();

            for (int i = 0; i < n; i++) {
                String line = br.readLine();
                StringTokenizer st = new StringTokenizer(line);
                st.nextToken(); // String name = st.nextToken();
                String type = st.nextToken();

                hashmap.put(type, hashmap.getOrDefault(type, 0) + 1);

//                if (hashmap.containsKey(type)) {
//                    hashmap.get(type).add(name);
//                } else {
//                    hashmap.put(type, new ArrayList<>());
//                    hashmap.get(type).add(name);
            }


            // 입는 옷의 종류 개수 * 그 종류에 속한 옷의 개수
            // 1개만 입을 때 -> name list 개수 다 합해주면 됨
            // 2개만 입을 때 -> 뭐 입을 거임? 종류 두 개 골라주고 -> 그 종류에 속한 옷들 개수 곱해줘
            int result = 1;

            for (int cnt : hashmap.values()) {
                result *= cnt+1;
            }

                System.out.println(result - 1); // 알몸(모든 종류에서 아무것도 안 입는 경우) 제외

        }
    }
}

```

</details>

<details>
<summary>BOJ9461. 파도반수열</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_lunchStudy/BOJ9461_%ED%8C%8C%EB%8F%84%EB%B0%98%EC%88%98%EC%97%B4.java)
> **_DP_**
>
> - 규칙 찾느라 노가다 좀 했음
> - int 배열로 dp 저장해주니까 int가 표현할 수 있는 값을 벗어나서 long으로 바꿔줌  
>   근데 이걸 어떻게 문제 보면서 바로 int 쓸 지 long 쓸 지 파악할 수 있을까?

```
package groupstudy.algorithm_lunchStudy;

import java.util.Scanner;

public class BOJ9461_파도반수열 {
    /**
     * 파도반수열
     * <a href="https://www.acmicpc.net/problem/9461">...</a>
     */

    /*
    dp 배열을 int로 쓰니까 틀렸다고 함... 범위를 넘어갔나봄...그래서 long으로 썼어
    근데 이걸 문제만 보고 어케 int 써야할지 long 써야할지 판단하지?
     */
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();

        long[] dp = new long[101];
        dp[1] = 1;
        dp[2] = 1;
        dp[3] = 1;
        dp[4] = 2;
        dp[5] = 2;
        dp[6] = dp[3] + dp[5];
        dp[7] = dp[2] + dp[6];
        dp[8] = dp[1] + dp[7];
        for(int i = 9 ; i < 101 ; i++){
            dp[i] = dp[i-1] + dp[i-5];
        }

        for(int Main = 1 ; Main <= T ; Main++) {
            int N = sc.nextInt();

            System.out.println(dp[N]);
        }
    }
}

```

</details>

<details>
<summary>SWEA8931. 제로</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA8931_%EC%A0%9C%EB%A1%9C.java)
> **_Stack_**
>
> - stack 기본 중의 기본 중의 기본. 걍 바로 풀고 바로 맞았음.

```
import java.util.Scanner;
//import java.util.Stack;

public class SWEA8931_제로 {
	/**
	 * 제로
	 */

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for(int Main = 1; Main <= T ; Main++) {
			int K = sc.nextInt();
			MyStack<Integer> stack = new MyStack<>();

			for(int k = 0 ; k < K ; k++) {
				int num = sc.nextInt();
				if(num != 0) {
					stack.add(num);
				} else {
					stack.pop();
				}
			}

			int sum = 0;
			while(!stack.isEmpty()) {
				sum += stack.pop();
			}

			System.out.println("#" + Main + " " + sum);
		}
	}
}

```

</details>

<details>
<summary> Stack 구현해보기  </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/MyStack.java)
> **_Stack_**  
> 전에 DoublyLinkedList 구현했던 것보단 훨씬 간단했다  
> 근데 일반 배열로 구현하자니 남는 메모리가 너무 거슬려서  
> ArrayList로 써서 편하게 하긴 함...  
> 구현 자체보다는 제네릭 문법이 조금 헷갈려서 찾아봐가면서 했다

```
import java.util.ArrayList;

public class MyStack<T> {
	ArrayList<T> stack = new ArrayList<>();
	T top;

	public void add(T data) {
		stack.add(data);
		top = data;
	}

	public T pop() {
		if (!stack.isEmpty()) {
			T temp = top;
			stack.remove(stack.size()-1);
			if (!stack.isEmpty()) {
				top = stack.get(stack.size() - 1);
			} else {
				top = null;
			}
			return temp;
		} else {
			return null;
		}
	}

	public int size() {
		return stack.size();
	}

	public T peek() {
		return this.top;
	}

	public void clear() {
		stack.clear();
	}

	public boolean isEmpty() {
		if (stack.size() == 0)
			return true;
		else
			return false;
	}
}

```

</details>

<br>

**2025.02.14 금요일**

<details>
<summary>BOJ11659. 구간 합 구하기 4  </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_lunchStudy/BOJ11659_%EA%B5%AC%EA%B0%84%ED%95%A9%EA%B5%AC%ED%95%98%EA%B8%B04.java)
> **_누적합_**
>
> - 처음에는 arr에 숫자 담아주고 i-1 부터 j-1까지 더해줬는데 당연히 시간초과. 사실 좀 예상했음.
> - 누적합 쓰는 걸 생각 못하고 있었던 건 아니라서... 실패 뜨자마자 쓰고 통과

```
package groupstudy.algorithm_lunchStudy;

import java.io.*;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ11659_구간합구하기4 {
    /**
     * 구간합구하기4
     * <a href="https://www.acmicpc.net/problem/11659">...</a>
     */
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        int[] arr = new int[N];

        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            if (i == 0) {
                arr[i] = Integer.parseInt(st.nextToken());
            } else {
                arr[i] = arr[i - 1] + Integer.parseInt(st.nextToken());
            }
        }

        for(int m = 0 ; m < M ; m++) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken());
            int j = Integer.parseInt(st.nextToken());
            if(i == 1) {
                bw.write(arr[j-1] + "\n");
                bw.flush();
            } else {
                bw.write((arr[j - 1] - arr[i - 2]) + "\n");
                bw.flush();
            }
        }
    }
}

```

</details>

<details>
<summary>SWEA5356. 의석이의 세로로 말해요 </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA5356_%EC%9D%98%EC%84%9D%EC%9D%B4%EC%9D%98%EC%84%B8%EB%A1%9C%EB%A1%9C%EB%A7%90%ED%95%B4%EC%9A%94.java)
> **_배열순회_**
>
> - 이거 걍 열 우선 탐색 하면서 null 인 애들 패스해주면 되겠는데?
> - 쉬웠음... 배열 크기 최대값으로 맞춰주니까 편함

```
import java.util.Scanner;

public class SWEA5356_의석이의세로로말해요 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int Main = 1; Main <= T; Main++) {
			// 2차원 배열을 만들어야 할 거야
			// 길이를 어떻게 정해주지? -> 길이 15 이하래 걍 다 15로 맞추자
			String[][] map = new String[15][15];

			// 각 테스트 케이스는 다섯 줄
			for (int i = 0; i < 5; i++) {
				// 한 줄 읽어오면 쪼개주고
				String line = sc.next();
				String[] parts = line.split("");
				// 쪼갠 거 차곡차곡 넣어줌
				for (int j = 0; j < parts.length; j++) {
					map[i][j] = parts[j];
				}
			}

			// 이제 출력해줘야 해
			System.out.print("#" + Main + " ");

			for (int j = 0; j < 15; j++) {
				for (int i = 0; i < 15; i++) {
					if (map[i][j] != null) {
						System.out.print(map[i][j]);
					}
				}
			}

			System.out.println();

		}
	}
}

```

</details>

<details>
<summary>SWEA4613. 러시아 국기 같은 깃발</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA4613_%EB%9F%AC%EC%8B%9C%EC%95%84%EA%B5%AD%EA%B8%B0%EA%B0%99%EC%9D%80%EA%B9%83%EB%B0%9C.java)
> - 진심 어이 없는 데서 실수해서 계속 틀린 거였음…  
>   red 세는 조건 시작지점을 endB로 해야 하는데 startB로 해가지고… 바본가 진짜;;  
>   어쩐지 논리는 아무리 생각해도 맞는데 답은 틀렸더라ㅠ
> - 시간복잡도 가늠 안 됨………
> - cnts 배열 따로 만들어주는 걸 떠올린 게 진짜 뿌듯했다 !
> - 나는 파란색 범위를 시작이랑 끝 정하고 좁혀줬는데, 솔빈이 코드 보니까 파란색 범위 정하는 부분을 나랑 다르게 구현해놨음.  
>   다른 부분은 전체적으로 비슷하게 풀었길래 뿌듯했다.

```
// 솔빈이 풀이
for (int i=1;i<=n-2;i++) {
    int wSum = 0;
    for (int j=0;j<i;j++) {
        wSum+=m-cnt[j][0];
    }
    for (int j=i+1;j<=n-1;j++) {
        int bSum = 0;
        for (int k=i;k<j;k++) {
            bSum+=m-cnt[k][1];
        }
        int rSum = 0;
        for (int k=j;k<n;k++) {
            rSum+=m-cnt[k][2];
        }
        min = Math.min(min, wSum+bSum+rSum);
    }
}
```

```
// 내 풀이
import java.util.Scanner;

public class SWEA4613_러시아국기같은깃발 {

	// 첫 번째 줄은 무조건 흰색이어야 해
	// -> 두 번째 줄 흰색할지 파랑할지 개수 세어 보고 정하자
	// -> 흰색이면 그 다음 줄에서도 방금 단계 반복하고
	// 파랑이면 그 다음 줄 파랑할지 빨강할지 정해야 해
	// 마지막 줄은 무조건 빨강이어야 함

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int T = sc.nextInt();
		for (int Main = 1; Main <= T; Main++) {
			int n = sc.nextInt();
			int m = sc.nextInt();

			int mincnt = n*m ;	// 답 담아줄 변수 미리 선언

			// 일단 입력대로 이차원배열 만들어주기
			String[][] map = new String[n][m];
			for (int i = 0; i < n; i++) {
				String line = sc.next();
				String[] split = line.split("");
				for (int j = 0; j < m; j++) {
					map[i][j] = split[j];
				}
			}

			// 각 줄마다 각 색깔로 바꿨을 때 몇 개씩 바꿔줘야 하는지 담아줄 것
			int[][] cnts = new int[n][3];

			for (int i = 0; i < n; i++) {
				for (int j = 0; j < m; j++) {
					if (!map[i][j].equals("W")) {
						cnts[i][0]++;
					}

					if (!map[i][j].equals("B")) {
						cnts[i][1]++;
					}

					if (!map[i][j].equals("R")) {
						cnts[i][2]++;
					}
				}
			}

//			// cnts 배열 테스트 출력
//			for(int i= 0 ; i < n ; i++) {
//				for(int j = 0 ; j < 3; j++) {
//					System.out.print(cnts[i][j]);
//				}
//				System.out.println();
//			}

			// 약간 계단 오르기 문제처럼 풀어야 하나? 한 칸 갔을 때와 두 칸 갔을 때 구분했던 것처럼...
			// 근데 이때는 행이 계단이 아니라 색깔이 계단이어야지. 단계가 있잖아.

			// 맨 뒤에서부터 봤을 때 마지막은 무조건 R
			// 얘는 B에서 왔을 수도 있고, R에서 왔을 수도 있어
			// B에서 왔으면
			// W에서 왔을 수도 있고 B에서 왔을 수도 있고
			// W에서 왔으면 그 앞은 쭉 W여야 해
			// B에서 왔으면 그 앞은 W에서 왔을 수도 있고 B에서 왔을 수도 있어...
			// R에서 왔으면
			// B에서 왔을 수도 있고 R에서 왔을 수도 있어

			// 정리하자면
			// 1. 무조건 첫째줄은 W, 마지막 줄은 R
			// 2. 전체 행 개수 - W행 개수 - R행 개수 했을 때 남은 개수가 2 이상이면
			// 매번 W인지 B인지 or B인지 R인지 탐색해줘야 한다

			// B인 줄의 시작 위치와 마지막줄 위치가 관건
			// 시작 위치는 1 -> n-2
			// 끝 위치는 n-2 -> 1
			// 근데 둘이 똑같아지면 끝나야 함


			for (int startB = 1; startB <= n - 2; startB++) {
				for (int endB = n - 2; endB >= startB; endB--) {
					/*
					 * startB == 1 이고 endB == n-2일 때
					 * cnts[0][0] + cnts[1][1] ~ cnts[n-2][1] + cnts[n-1][2]
					 *
					 * startB == 2 이고 endB == n-2일 때
					 * cnts[0][0] + cnts[1][1] ~ cnts[n-2][1] + cnts[n-1][2]
					 *
					 * ...
					 *
					 * startB == n-2 이고 endB == n-2일 때
					 *
					 * 까지 하고 나서
					 * startB = 2이고 endB == n-2일 때 부터 쭉....
					 */
					int cnt = 0;

					for(int i = 0; i < startB ; i++) {
						cnt += cnts[i][0];
					}

					for(int i = startB ; i <= endB ; i ++) {
						cnt += cnts[i][1];
					}



					for(int i = endB + 1 ; i <= n-1 ; i++) {
						cnt += cnts[i][2];
					}

					mincnt = Math.min(cnt, mincnt);
				}
			}

			System.out.println("#" + Main + " " + mincnt);

		}

	}
}

// 아니 진심 멍청인가 마지막 red 조건 startB+1부터로 잡아줘서 오류남;;;;
// 코드 짤 때 덜렁거리는 거 어케 고치지 진짜.........
// 어쩐지 아무리 생각해도 논리는 다 맞는데 틀렸다더라.......짱나네 ㅋㅋ

```

</details>

<br>

**2025.02.15 토요일**

<details>
<summary> SWEA5432. 쇠막대기 자르기 </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA5432_%EC%87%A0%EB%A7%89%EB%8C%80%EA%B8%B0%EC%9E%90%EB%A5%B4%EA%B8%B0.java)
> **_stack_**
>
> - 자를 때마다 sum += 현재 층수  
>   근데 ( 만나면 sum에 1 더해줘야 함. 이거 안 더해주면 \* 기준 오른쪽만 더하는 꼴이 됨
> - 사실 자르는 부분을 \*로 바꿔주는 단계 없이 하나씩 빼면서 바로바로 처리해주는 게 더 좋긴 하지만 처음에 좀 복잡하게 생각했어서...안 헷갈리려고 이렇게 했음

```
import java.util.Scanner;
import java.util.Stack;

public class SWEA5432_쇠막대기자르기 {
    /**
     * 쇠막대기 자르기
     * IM 대비 문제
     */

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();
        for (int Main = 1; Main <= T; Main++) {
            String str = sc.next();
            String[] arr = str.split("");
            Stack<String> stack = new Stack<>();
            int floor = 0;
            int sum = 0;

            for (String s : arr) {
                if (stack.isEmpty()) {
                    stack.push(s);
                } else {
                    if (s.equals(")")) {
                        if (stack.peek().equals("(")) {
                            stack.pop();
                            stack.add("*");
                        } else {
                            stack.add(s);
                        }
                    } else {
                        stack.add(s);
                    }
                }
            }

//            System.out.println(stack);

            while (!stack.isEmpty()) {
                String s = stack.pop();
                if(s.equals(")")) {
                    floor ++;
//                    System.out.println(") 만났고 현재 층수 " + floor);
                } else if (s.equals("*")) {
                    sum += floor;
//                    System.out.println("* 만났고 현재 층수 " + floor + " 현재 sum " + sum);
                } else if (s.equals("(")) {
                    sum++;
                    floor --;
//                    System.out.println("( 만났고 현재 층수 " + floor + " 현재 sum " + sum);
                }

            }

            System.out.println("#" + Main + " " + sum);
        }
    }
}

```

</details>

<details>
<summary> SWEA1224. 계산기3 </summary> 

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA1224_%EA%B3%84%EC%82%B0%EA%B8%B03.java)
> ***stack***  
> - 후위계산식으로 변환하는 게 너무 헷갈려... 이해가 영 안 되는 건 아닌데 만들자니 헷갈려서 공식처럼 외워서 이해하는 게 나을 것 같음

```
import java.util.*;


public class SWEA1224_계산기3 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        for (int Main = 1; Main <= 10; Main++) {
            int len = sc.nextInt();
            String str = sc.next();
            Stack<Character> op = new Stack<>();

            StringBuilder sb = new StringBuilder();

            Map<Character, Integer> map = new HashMap<>();
            map.put('(', 0);
            map.put('*', 1);
            map.put('/', 1);
            map.put('+', 2);
            map.put('-', 2);


            for (int i = 0; i < str.length(); i++) {
//				System.out.println("이제 처리해줄 위치 : " + str.charAt(i));
                // 피연산자라면 출력
                if (str.charAt(i) >= '0' && str.charAt(i) <= '9') {
                    sb.append(str.charAt(i));
                }
                // 연산자라면
                else {
                    if (str.charAt(i) == '(')
                        op.push(str.charAt(i));

                    else if (str.charAt(i) == ')') {
                        while (op.peek() != '(') {
                            sb.append(op.pop());
                        }
                        op.pop();
                    } else {
                        if (op.isEmpty())
                            op.push(str.charAt(i));

                        else {
                            while (op.peek() != '(' && map.get(str.charAt(i)) >= map.get(op.peek())) {
                                sb.append(op.pop());
                            }
                            op.push(str.charAt(i));
                        }

                    }

                }

//				System.out.println("방금 처리해준 위치 : " + str.charAt(i));
//				System.out.println("현재 출력 : " + sb);
//				System.out.println("현재 스택 : " + op);
            }

            while (!op.isEmpty()) {
                sb.append(op.pop());
            }

//            System.out.println(sb);

            str = sb.toString();

            Stack<Integer> cal = new Stack<>();

            for (int i = 0; i < str.length(); i++) {
				if(str.charAt(i) >= '0' && str.charAt(i) <= '9') {
					cal.push(str.charAt(i) - '0');
				} else {
					int b = cal.pop();
					int a = cal.pop();

					if( str.charAt(i) == '+') {
						cal.push(a+b);
					}

					else if( str.charAt(i) == '-') {
						cal.push(a-b);
					}

					else if( str.charAt(i) == '*') {
						cal.push(a*b);
					}

					else if( str.charAt(i) == '/') {
						cal.push(a/b);
					}
				}
            }


			while (!cal.isEmpty()) {
				System.out.println("#" + Main + " " +  cal.pop());
			}

        }

    }
}

```
</details>

<details>
<summary>정렬 연습 (SelectionSort, QuickSort, MergeSort) </summary>

[코드](https://github.com/leeozzi/study/tree/master/Knowledge/dataStructure/sorting)
> **_SelectionSort, QuickSort, MergeSort_**
</details>

<br>

**2025.02.16 일요일**

<details>
<summary>BOJ11726. 2xN 타일링</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_lunchStudy/BOJ11726_2xN%ED%83%80%EC%9D%BC%EB%A7%81.java)
> **_DP_**
> - 사실 이거 예전에 싸피 비전공자 CT 시험 대비할 때 본 적 있는 문제라서 점화식을 알고는 있었는데  
>   납득이 잘 안 돼서 나름대로 처음부터 풀어보려고 했음.  
>   f(n-2)에 두 칸짜리 타일을 더하는 경우 & f(n-1)에 한 칸짜리 타일을 더하는 경우로 나누어진다는 건 알았는데  
>   타일을 더할 때 앞에 더할지, 중간에 더할지, 뒤에 더할지 또 나뉘는 게 아닌가? 라는 생각이 자꾸 들었다. 괜한 호승심 ㅜ  
>   근데 혼자 처음부터 설계하다가 꼬여서 그냥 기존에 알고 있던 공식을 증명하는 방식으로 틀었더니 납득이 됐다.  
>   그려보니까 어차피 f(n-2)랑 f(n-1) 단계에서 그 경우의 수들을 다 포함하면서 올라오는 거였음. 허무해...ㅋㅋㅋ
> - 근데 이거 직접 해보면서 잘못된 공식을 세운 덕분에 Math.pow(num, power) 함수를 알게됐다. 그럼그렇지 제곱 함수가 없을 리가 없어.

```
package groupstudy.algorithm_lunchStudy;

import java.util.Scanner;

public class BOJ11726_2xN타일링 {
    /**
     * 2xN 타일링
     * <a href="https://www.acmicpc.net/problem/9375">...</a>
     */
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] dp = new int[1001];
        // dp의 인덱스는 전체 길이 n
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3 ; i < dp.length ; i++) {
            dp[i] = (dp[i-2] + dp[i-1]) % 10007;
        }

        System.out.println(dp[n]);

    }
}

```
</details>

<details>
<summary>SWEA21936. 길이가 M인 회문 찾기</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA21936_%EA%B8%B8%EC%9D%B4%EA%B0%80M%EC%9D%B8%ED%9A%8C%EB%AC%B8%EC%B0%BE%EA%B8%B0.java)
> **_탐색_**
> - 난이도가 D1이길래 만만하게 보고 풀었다가 생각보다 좀 꼬였다. 푸는 데 1시간 정도 걸린 듯?  
>   매번 난이도 쉬운 문제마다 이러는 것 같다.
>   접근법을 모르겠다거나 어려운 건 아닌데, 더 고급지게 풀고 싶다는 욕심에 단순한 답을 두고 어렵게 고민하는 경향이 있다.  
>   안 좋은 버릇...고쳐야지. 난이도만 보고 만만하게 보지 말 것 !

```
package SWEA;

import java.util.Scanner;

public class SWEA21936_길이가M인회문찾기 {
    /**
     * 길이가 M인 회문 찾기
     * <a href="https://swexpertacademy.com/main/code/userProblem/userProblemDetail.do?contestProbId=AZFkKmLa1zEDFAQW">...</a>
     */

    public static void main(String[] args) {
        // start = 0 -> n-m 까지 옮기면서
            // i = 0 -> m/2
                // start + i 랑 start + m - 1 - i 랑 같은지 비교
                // 달라지면 break
        // 반복문 끝나면 start 부터 start + m-1-i 까지 출력

        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();

        for(int Main = 1 ; Main <= T ; Main++) {
            int N = sc.nextInt();
            int M = sc.nextInt();
            String str = sc.next();
//            System.out.println(str);
            boolean flag = false;

            for(int i = 0 ; i <= N-M ; i++) {
//                System.out.println(i + "에서 시작하는 문자열");
                for ( int j = 0 ; j <= (M-1)/2 ; j++) {
                    if (str.charAt(i + j) == str.charAt(i + M - 1 - j)) {
                        flag = true;
//                        System.out.println(str.charAt(i + j) + " vs " + str.charAt(i + M - 1 - j));
                    } else {
                        flag = false;
//                        System.out.println(str.charAt(i + j) + " vs " + str.charAt(i + M - 1 - j));
                        break;
                    }
                }
                if(flag) {
//                    System.out.println("문자열 찾음 ! ");
                    System.out.print("#" + Main  + " ");
                    for(int j = i ; j <= i + M - 1 ; j++) {
                        System.out.print(str.charAt(j));
                    }
                    System.out.println();
                    break;
                }
            }

            if(!flag) {
                System.out.println("#" + Main  + " NONE");
            }




        }
    }
}

```
</details>

<details>
<summary>SWEA12712. 파리잡기3</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA12712_%ED%8C%8C%EB%A6%AC%ED%87%B4%EC%B9%983.java)
> **_2차원배열 탐색_**
> - 사전학습 때 풀어본 문제기도 하고 워낙 많이 해본 종류의 문제다 보니 설계는 진짜 금방 했는데 자꾸 값이 틀리게 나와서 당황했다.  
>   알고보니 곱하기 모양 델타값을 잘못 설정해줌......  
>   이런 사소한 실수들 언제쯤 줄어들까ㅠ

```
package SWEA;

import java.util.Scanner;

public class SWEA12712_파리퇴치3 {
    /**
     * 파리퇴치3
     * <a href="https://swexpertacademy.com/main/code/userProblem/userProblemDetail.do?contestProbId=AXuARWAqDkQDFARa">...</a>
     */

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();

        for (int Main = 1; Main <= T; Main++) {
            int N = sc.nextInt();
            int M = sc.nextInt();
            int[][] map = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    map[i][j] = sc.nextInt();
                }
            }

//            for(int i= 0 ; i < N ; i++) {
//                for(int j = 0 ; j < N ; j++) {
//                    System.out.print(map[i][j] + " ");
//                }
//                System.out.println();
//            }

            int max = 0;

            int[] dx1 = {-1, 0, 1, 0};
            int[] dy1 = {0, 1, 0, -1};

            int[] dx2 = {-1, -1, 1, 1};
            int[] dy2 = {-1, 1, -1, 1};

            // 한 위치에서 +, x 둘 다 검사해야 함
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
//                    System.out.println("현재 위치 : (" + i + "," + j + ")");
                    // + 검사
                    int plussum = map[i][j];
                    for (int m = 1; m < M; m++) {
                        for (int d = 0; d < 4; d++) {
                            int nx = i + dx1[d] * m;
                            int ny = j + dy1[d] * m;

                            if (nx >= 0 && ny >= 0 && nx < N && ny < N) {
//                                System.out.print(map[nx][ny] + " ");
                                plussum += map[nx][ny];
//                                System.out.println("현재 plussum : " + plussum);
                            }
                        }
//                        System.out.println();

                    }

                    // x 검사
                    int xsum = map[i][j];
                    for (int m = 1; m < M; m++) {
                        for (int d = 0; d < 4; d++) {
                            int nx = i + dx2[d] * m;
                            int ny = j + dy2[d] * m;

                            if (nx >= 0 && ny >= 0 && nx < N && ny < N) {
                                xsum += map[nx][ny];
                            }

                        }
                    }

                    // 두 개 중 더 큰 값 비교
//                    System.out.println("현재 위치 : (" + i + "," + j + ")");
//                    System.out.println("xsum : " + xsum + " plussum : " + plussum);
                    max = Math.max(max, Math.max(xsum, plussum));
                }

            }

            System.out.println("#" + Main + " " + max);
        }
    }
}

```

</details>

<details>
<summary>SWEA11315. 오목판정</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA11315_%EC%98%A4%EB%AA%A9%ED%8C%90%EC%A0%95.java)
> **_2차원배열 탐색_**
>
> - 반복문이 많아지면 일단 머리가 아프다. 일단 앞에 indent 가 늘어나면 뭔가가 크게 잘못되어가고 있는 듯한 기분...

```
package SWEA;

import java.util.Scanner;

public class SWEA11315_오목판정 {
    /**
     * 오목판정
     * <a href="https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AXaSUPYqPYMDFASQ">...</a>
     */

    static char[][] board;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();
        for (int Main = 1; Main <= T; Main++) {
            // 판 만들기
            int N = sc.nextInt();
            board = new char[N][N];
            for (int i = 0; i < N; i++) {
                String str = sc.next();
                for (int j = 0; j < N; j++) {
                    board[i][j] = str.charAt(j);
                }
            }

            // o 찾기
            if (search()) {
                System.out.println("#" + Main + " YES");
            } else {
                System.out.println("#" + Main + " NO");
            }

        }
    }

    private static boolean search() {
        int[] dx = {0, 1, 1, -1};
        int[] dy = {1, 0, 1, 1};

        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board.length; j++) {
                if (board[i][j] == 'o') {
                    for (int d = 0; d < 4; d++) {
                        int cnt = 1;
                        for (int n = 1; n < 5; n++) {
                            int nx = i + dx[d] * n;
                            int ny = j + dy[d] * n;

                            if (nx >= 0 && ny >= 0 && nx < board.length && ny < board.length) {
                                if (board[nx][ny] == 'o') {
                                    cnt++;
                                } else {
                                    break;
                                }
                            }
                        }
                        if (cnt == 5) {
                            return true;
                        }
                    }
                }
            }
        }

        return false;
    }
}

```
</details>

<br>

**2025.02.17 월요일**

<details> 
<summary>SWEA6485. 삼성시의 버스 노선</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA6485_%EC%82%BC%EC%84%B1%EC%8B%9C%EC%9D%98%EB%B2%84%EC%8A%A4%EB%85%B8%EC%84%A0.java)
> - 문제 이해하는 게 오래 걸려서 그렇지 푸는 것 자체는 어렵지 않았음
> - 문제가 너무 읽기 귀찮아서 일단 냅다 입력 받을 것부터 입력 받고 시작했더니 훨씬 빠르게 이해가 됐다

```
package SWEA;

import java.util.Scanner;

public class SWEA6485_삼성시의버스노선 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();

        for(int Main = 1; Main <= T ; Main++) {
            int[] arr = new int[5001];
            System.out.print("#" + Main + " ");
            int N = sc.nextInt();   // 버스 노선
            for (int n = 1; n <= N; n++) {  // 노선마다 수행해줌
                int A = sc.nextInt();   // 해당 노선의 출발
                int B = sc.nextInt();   // 해당 노선의 도착
                for(int i = A ; i <= B ; i++) {
                    arr[i] ++;  //  정류장 지나가면서 cnt 하나씩 올려줘
                }
            }

            int P = sc.nextInt();   // 노선 개수 구해줄 정류장 개수
            for (int p = 1; p <= P; p++) {
                int C = sc.nextInt();
                System.out.print(arr[C] + " ");
            }

            System.out.println();
        }
    }
}

```
</details>

<details>
<summary>SWEA7102. 준홍이의 카드놀이</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA7102_%EC%A4%80%ED%99%8D%EC%9D%B4%EC%9D%98%EC%B9%B4%EB%93%9C%EB%86%80%EC%9D%B4.java)
> - 오늘 시험도 그렇고 버스 노선도 그렇고...자꾸 카운트 배열열만 쓰는 기분인데....메모리가 낭비되고 있는 듯한 찜찜함.....
> - 솔빈이 코드 설명 들었는데 솔빈이는 가장 자주 등장하는 숫자를 수학적 규칙으로 찾아내서 풀었다. 훨씬 간단하고 좋아서 나도 저렇게 풀고 싶어  
>   (=> N까지의 숫자와 M까지의 숫자를 더해서 나올 수 있는 조합 중 가장 많이 등장하는 값은 N+1부터 M+1까지)

```
// 솔빈이 풀이
int min = Math.min(n, m);
int max = Math.max(n, m);
for (int i = min + 1; i <= max + 1; i++) {
    sb.append(" ").append(i);
}
```

```
// 내 풀이
import java.util.Scanner;

public class SWEA7102_준홍이의카드놀이 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();
        for(int Main = 1; Main <= T ; Main++) {
            System.out.print("#" + Main + " ");
            int N = sc.nextInt();
            int M = sc.nextInt();

            int[] cnt = new int[N+M+1];

            for(int i = 1; i <= N ; i++){
                for(int j = 1; j <= M ; j++)
                    cnt[i+j] ++;
            }

            int max = 0;
            for(int i= 0 ; i < cnt.length; i++)
                max = Math.max(max, cnt[i]);


            for(int i = 0 ; i < cnt.length;i++) {
                if(cnt[i] == max)
                    System.out.print(i + " ");
            }
            System.out.println();
        }
    }
}

```
</details>

<details>
<summary>SWEA6190. 정곤이의 단조 증가하는 수</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA6190_%EC%A0%95%EA%B3%A4%EC%9D%B4%EC%9D%98%EB%8B%A8%EC%A1%B0%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94%EC%88%98.java)
> - 문제 제대로 읽을 것 ㅠㅠ 단조 증가하는 수가 없다면 -1을 출력한다는 부분 못 봐서 한 번 틀렸다

```
package SWEA;

import java.util.Scanner;

public class SWEA6190_정곤이의단조증가하는수 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();

        for (int Main = 1; Main <= T; Main++) {
            // 숫자들 배열에 담아주기
            int N = sc.nextInt();
            int[] arr = new int[N];
            for (int n = 0; n < N; n++) {
                arr[n] = sc.nextInt();
            }

            int max = -1;

            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    int mul = arr[i] * arr[j];

                    // mul이 단조 증가하는 수인지 판단해 줄 거야
                    String mul2 = mul + "";
                    int loc = 0;
                    // 글자 하나씩 지나가면서 끝까지 증가하면 max 갱신
                    for (int l = 0; l < mul2.length() - 1; l++) {
                        if (mul2.charAt(l) > mul2.charAt(l + 1)) break; // 감소했다면 그만 봐
                        loc++;  // 증가 중이라면 loc 올려줘
                    }
                    // mul 길이 다 돌고 나서
                    if (loc == mul2.length() - 1) {    // loc가 끝까지 증가했으면
                        max = Math.max(max, mul);
                    }
                }
            }



            System.out.println("#" + Main + " " + max);
        }
    }
}

```
</details>

<details>
<summary>SWEA3499. 퍼펙트 셔플</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA3499_%ED%8D%BC%ED%8E%99%ED%8A%B8%EC%85%94%ED%94%8C.java)
> - 쉽게 풀기는 했는데 뭔가 너무 단순하게 푼 것 같아서 이래도 되나 싶음

```
import java.util.Scanner;

public class SWEA3499_퍼펙트셔플 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();

        for(int Main = 1 ; Main <= T ; Main++) {
            System.out.print("#" + Main + " ") ;
            // 카드 리스트 만들어주기
            int N = sc.nextInt();
            String[] cards = new String[N];
            for(int i = 0 ; i < N ; i++) {
                cards[i] = sc.next();
            }

            // 반으로 쪼갠 카드리스트 두 개 만들어주기
            String[] cards1 = new String[(N+1)/2];  // 홀수일 경우 얘한테 하나 더 넣어줄 거야
            String[] cards2 = new String[N/2];

            for(int i = 0 ; i < (N+1)/2 ; i++) {
                cards1[i] = cards[i];
            }

            for(int i = (N+1)/2 ; i < N ; i++) {
                cards2[i-(N+1)/2] = cards[i];
            }

            for(int i= 0 ; i < (N+1)/2 ; i++) {
                System.out.print(cards1[i] + " ");
                if(i < N/2)
                    System.out.print(cards2[i] + " ");
            }
            System.out.println();
        }

    }
}

```
</details>

<details>
<summary> SWEA1989. 초심자의 회문 검사 </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA1989_%EC%B4%88%EC%8B%AC%EC%9E%90%EC%9D%98%ED%9A%8C%EB%AC%B8%EA%B2%80%EC%82%AC.java)
> - for문에 이름 붙여서 제어해줄 수 있다는 걸 알고는 있었는데 써 본 적은 없다가, 아까 솔빈이가 쓴 거 보고 써봤다. 확실히 훨씬 편한데 뭔가 편법 쓰는 기분이다.  
>   오목판정 풀 때도 그냥 얌전히 썼으면 조금은 더 쉽게 풀었을 것 같은데 괜히 오기부려서 오래 풀었나봐

```
package SWEA;

import java.util.Scanner;

public class SWEA1989_초심자의회문검사 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();
        testcase:
        for(int Main = 1; Main <= T ; Main++) {
            String word = sc.next();
            for(int i = 0 ; i < word.length()/2 ; i++) {
                if(word.charAt(i) != word.charAt(word.length()-1-i)) {
                    System.out.println("#" + Main + " " + 0);
                    continue testcase;
                }
            }
            System.out.println("#" + Main + " " + 1);
        }
    }
}

```

</details>

<details>
<summary> 알고리즘 과목 평가 - 호텔 방 배정하기 </summary>

> - 조건 나눠주는 거 평소에 어려워했는데 이번에 좀 잘한 것 같아서 뿌듯했다. 한 줄마다 주석 강제로 쓰면서 머리가 더 잘 정리된 듯
> - 근데 현욱이 코드 보니까 진짜 짧게 잘 짜서 신기했다. 많이 풀다 보면 저런 코드가 나오려나.

```

import java.util.Scanner;

public class Algo2_서울_9반_이언지 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in); // 입력 받아줄 스캐너

		int T = sc.nextInt(); // 테스트케이스 입력 받기
		for (int Main = 1; Main <= T; Main++) { // 테스트케이스만큼 반복
			int N = sc.nextInt(); // 초기 호텔의 객실수
			int M = sc.nextInt(); // 방문할 가족의 수

			int[] arr = new int[N]; // 객실 수만큼 방 만들어주기
			int idx = 0; // 어디부터 사람 넣어줄지 표시하는 인덱스

			for (int m = 0; m < M; m++) {
				int num = sc.nextInt(); // 이번에는 몇 명이 방문하나요 ?


				if (arr[0] == 0) { // 만약 첫칸이 비었으면
					for (int i = 0; i < num; i++) { // 첫 칸부터 num 칸만큼
						arr[i] = 1; // 사람을 넣어줘
					}
					idx = num + 1; // 다음 팀 넣어줄 첫 번째 인덱스
				}

				else { // 만약 첫 칸이 차 있으면 봐 가면서 넣어야 해
					if (idx + num - 1 <= arr.length - 1) { // 넣어줄 수 있는 시작점 ~ 마지막 방까지 인원수만큼 충분한 방이 비었으면
						for (int i = idx; i < idx + num; i++) { // idx번째 칸부터 num 칸만큼
							arr[i] = 1; // 사람을 넣어줘
						}
						idx = idx+num + 1; // 다음 팀 넣어줄 인덱스 업데이트
					} else if (idx + num - 2 <= arr.length - 1) { // idx번째 방부터는 없긴 한데 idx는 한 칸 띄우고 센 거니까...혹시나 한 칸 안 띄우고 세면 수용 가능할수도?
						for (int i = idx - 1; i < idx + num - 1; i++) { // idx-1 번째 칸부터 num 칸만큼
							arr[i] = 1; // 사람 넣어줘
						}
						idx = idx+num; // 인덱스 업데이트
					} else if (num == 1) { // 끝까지 왔는데 내가 한 명이야. 그럼 아까 띄워둔 방에 넣어줄 수도 있어
						for (int i = 0; i < arr.length; i++) { // 돌면서 빈칸 찾아서 넣어줄게
							if (arr[i] == 0)  { // 빈칸 찾음
								arr[i] = 1; // 냉큼 입장
								break;
							}
						}
					}
				}


//				System.out.println(Arrays.toString(arr));
			}

			int cnt = 0; // 다 넣어주고 나면 이제 빈 칸 개수 세줄거야
			for(int i= 0 ;i < arr.length ; i++) {	// 배열 전체 돌면서
				if(arr[i] == 0)	// 빈 칸 발견하면
					cnt++;	// cnt 올려주기
			}

			System.out.println("#" + Main + " " + cnt);	// 양식에 맞춰서 빈 칸 개수 출력
		}

	}
}

```
</details>

<details>
<summary>SWEA1225. 암호생성기</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA1225_%EC%95%94%ED%98%B8%EC%83%9D%EC%84%B1%EA%B8%B0_2.java)
> **_Queue_**
>
> - 삽입, 삭제 많으니까 LinkedList 써야지~ 하고 풀었는데 Queue 쓰는 문제였음 ㅎ 그래서 Queue로 다시 풀었어.
> - 근데 난이도에 비해 시간을 너무 쓰는 것 같음...ㅜ

```
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class SWEA1225_암호생성기_2 {
    /**
     * 암호생성기_2 (Queue 써서 풂)
     * <a href="https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV14uWl6AF0CFAYD&">...</a>
     */

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        for (int Main = 1; Main <= 10; Main++) {
            sc.nextInt();

            Queue<Integer> queue = new LinkedList<>();

            // 기존 숫자들 queue에 넣어주기
            for (int i = 0; i < 8; i++)
                queue.add(sc.nextInt());

            // cycle
            int i = 0;
            while (i++ <= 5) {
                int next = Math.max(queue.poll() - i, 0);
                queue.add(next);
                if(next == 0)
                    break;

                if(i == 5)
                    i = 0;

            }

            StringBuilder sb = new StringBuilder();
            sb.append("#" + Main + " ");
            while(!queue.isEmpty()) {
                sb.append(queue.poll() + " ");
            }
            System.out.println(sb);

        }
    }
}

```
</details>

<details>
<summary> SWEA2805. 농작물 수확하기 </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA2805_%EB%86%8D%EC%9E%91%EB%AC%BC%EC%88%98%ED%99%95%ED%95%98%EA%B8%B0.java)
> **_2차원 배열_**
>
> - 사방탐색을 할까, 그냥 행 내려오면서 더해줄까 고민했다. 사방탐색 도전했다가 너무 어려워서 그냥 별 찍기처럼 규칙 정해서 더해줬다.
> - 생각보다 오래 걸렸다. 사소하게 꼬인 경우도 많았음. 주석이나 메모를 하면서 했어야 하는데, 뭔가 설명 쓰는 게 더 어려워서 자꾸 냅다 코드 쓰다 꼬인 것 같다. 생각 정리하는 연습을 해야지.

```
package SWEA;

import java.io.*;

public class SWEA2805_농작물수확하기 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int T = Integer.parseInt(br.readLine());

        for (int Main = 1; Main <= T; Main++) {
            // map 만들어줄게
            int N = Integer.parseInt(br.readLine());
            int[][] map = new int[N][N];
            int[][] visited = new int[N][N];
            for (int i = 0; i < N; i++) {
                String str = br.readLine();
                String[] strs = str.split("");
                for (int j = 0; j < N; j++) {
                    map[i][j] = Integer.parseInt(strs[j]);
                }
            }

            int sum = 0;
            int len = 1;
            int startIdx = N / 2;
            for (int i = 0; i < N; i++) {   // 행 내려갈 때마다
                for(int j = startIdx ; j < startIdx + len ;j++) { // startIdx부터 길이만큼 더해줄 거야
                    sum += map[i][j];
                }

                if(i < N/2) {
                    len += 2;
                    startIdx--;
                } else {
                    len -=2;
                    startIdx++;
                }
//                System.out.println("현재 행 : " + i + " sum : " + sum);
            }


            System.out.printf("#%d %d\n", Main, sum);

        }
    }
}

```
</details>

<br>

**2025.02.18 화요일**

<details>
<summary>SW역량검정시험 A형 화분 키우기 (실패) </summary>

> - DP 쓰는 것까진 알았는데 세상에서 제일 더러운 코드를 쓰고 실패했다. 공개 테스트케이스 3개는 맞았는데 손으로 해본 거 틀려서...아마 밑에는 거의 다 틀리지 않았을까.
> - 규칙이 어렴풋이 감만 오고 구현이 안 된다. 언제쯤 생각한 게 챡챡 코드로 정돈이 될까.

```
import java.util.Scanner;

public class A_화분키우기_fail {


    public static void main(String args[]) throws Exception {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();

        for (int Main = 1; Main <= T; Main++) {
            int N = sc.nextInt();
            int P = sc.nextInt();

            // 첫 번째 [] = 몇 번째 화분인가?
            // 두 번째 [] = 몇 번째 비료인가?
            int[][] plants = new int[N][2];
            for (int n = 0; n < N; n++) {
                plants[n][0] = sc.nextInt();
            }
            for (int n = 0; n < N; n++) {
                plants[n][1] = sc.nextInt();
            }

            int[] dp1 = new int[N]; // 첫 번째 화분에 첫 번째 비료를 준 경우
            int prechoice = 0;
            int theother = 1;
            dp1[0] = plants[0][prechoice];
            for (int i = 1; i < N; i++) {
                if (i <= N - 2) {
                    if (dp1[i - 1] + plants[i][prechoice] - P
                            + Math.max(plants[i + 1][prechoice] - P, plants[i + 1][theother]) > dp1[i - 1]
                            + plants[i][theother]
                            + Math.max(plants[i + 1][prechoice], plants[i + 1][theother] - P)) {
                        dp1[i] = dp1[i - 1] + plants[i][prechoice] - P;
                    } else {
                        dp1[i] = dp1[i - 1] + plants[i][theother];
                        int temp = prechoice;
                        prechoice = theother;
                        theother = temp;
                    }

                } else {
                    if (dp1[i - 1] + plants[i][prechoice] - P > dp1[i - 1] + plants[i][theother]) {
                        dp1[i] = dp1[i - 1] + plants[i][prechoice] - P;
                    } else {
                        dp1[i] = dp1[i - 1] + plants[i][theother];
                        int temp = prechoice;
                        prechoice = theother;
                        theother = temp;
                    }
                }
            }

//			System.out.println(Arrays.toString(dp1));

            int[] dp2 = new int[N]; // 첫 번째 화분에 두 번째 비료를 준 경우
            prechoice = 1;
            theother = 0;
            dp2[0] = plants[0][1];
            for (int i = 1; i < N; i++) {
                if (i <= N - 2) {
                    if (dp2[i - 1] + plants[i][prechoice] - P
                            + Math.max(plants[i + 1][prechoice] - P, plants[i + 1][theother]) > dp2[i - 1]
                            + plants[i][theother]
                            + Math.max(plants[i + 1][prechoice], plants[i + 1][theother] - P)) {
                        dp2[i] = dp2[i - 1] + plants[i][prechoice] - P;
                    } else {
                        dp2[i] = dp2[i - 1] + plants[i][theother];
                        int temp = prechoice;
                        prechoice = theother;
                        theother = temp;
                    }

                } else {
                    if (dp2[i - 1] + plants[i][prechoice] - P > dp2[i - 1] + plants[i][theother]) {
                        dp2[i] = dp2[i - 1] + plants[i][prechoice] - P;
                    } else {
                        dp2[i] = dp2[i - 1] + plants[i][theother];
                        int temp = prechoice;
                        prechoice = theother;
                        theother = temp;
                    }
                }
            }

//			System.out.println(Arrays.toString(dp2));

            int sum = Math.max(dp1[N - 1], dp2[N - 1]);

            System.out.println("#" + Main + " " + sum);
        }
    }
}

```
</details>

<details>
<summary>SW역량검정시험 IM 공 굴리기</summary>

> - 설계 + 구현 포함해서 1시간 15분 정도 걸렸다
> - 조건이 엄청 많은 편이 아니라서, bfs dfs 문제 풀어본 거 중에 평이한 난이도 수준? 그냥 세세하게 조금씩 꼬이는 것만 있었지 크게 문제되는 건 없었다
> - 다만 아쉬운 점... 재귀로 풀었는데 이거 스택 메모리 너무 많이 쓸 것 같아서 재귀 없이 다시 풀어봐야겠음음

```
// 재귀 쓴 코드
import java.util.Scanner;

public class IM_공굴리기 {
    static int[][] map;
    static int[][] visited;
    static int cnt;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();

        for (int Main = 1; Main <= T; Main++) {
            // map 만들기
            int N = sc.nextInt();
            map = new int[N][N];

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    map[i][j] = sc.nextInt();
                }
            }

            int maxcnt = 0;
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    cnt = 1;
                    visited = new int[N][N];
                    // 출발 위치 넘겨서 dfs 돌리고, 출발 위치별로 다 비교해서 최대값 구하기
                    maxcnt = Math.max(maxcnt, move(i, j));
                }
            }

            System.out.printf("#%d %d \n", Main, maxcnt);
        }
    }

    private static int move(int i, int j) {
//        System.out.println("현재 위치 :  " + j + " " + j);

        visited[i][j] = 1;

        int[] dx = {-1, 0, 1, 0};
        int[] dy = {0, -1, 0, 1};

        // 네 방향 중 가장 낮은 값
        int cur = map[i][j];
        // 과 그 인덱스
        int minx = -1;
        int miny = -1;

        for (int d = 0; d < 4; d++) {
            int nx = dx[d] + i;
            int ny = dy[d] + j;

            // map 범위 벗어나지 않는 선에서 사방 탐색할 거야
            if (nx >= 0 && nx < map.length && ny >= 0 && ny < map.length ) {
                // 자 이제 나보다 작은데 내가 아직 안 가본 애들 골라줘
                if(map[nx][ny] < cur && visited[nx][ny] == 0) {
                    cur = map[nx][ny];  // 나를 옮겨주고
                    visited[nx][ny] = 1;    // visited 체크해줘
                    minx = nx;
                    miny = ny;
                }
            }
        } // 이거 통과했으면 이제 한 칸 이동한 거임

        if(minx != -1) {
            cnt ++; // 방금 저거 통과한 애가 동서남북 중에 하나라도 있었으면(= 이동했으면) cnt 올려줘
//            System.out.print(cnt + " ");
            move(minx, miny);    // 그리고 방금 그 위치에서 또 이동해줘야지
        } else {
            return cnt; // 갈 데 없어지면 끝내고 cnt 리턴해줘
        }

        return cnt;


    }
}

```
</details>

<br>

**2025.02.19 수요일**

<details>
<summary> BOJ17626. Four Squares </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_lunchStudy/BOJ17626_FourSquares.java)
> **_DP_**
>
> - 최대 제곱수 빼고 나머지 숫자 인덱스로 dp에서 찾고 1 더해주면 되겠다! 까지는 진짜 문제 보자마자 생각함
> - 근데 최대 제곱수가 아니라 한 중간쯤 되는 제곱수 두 개 쓸 수도 있는 거였음...아무리 생각해도 이걸 찾아줄 방법이 생각 안 나서 gpt한테 도움 요청
> - 제곱수 다 빼보고, 그 나머지 찾고 1 더한 최소값 저장하는 코드를 줌.
> - 나 약간 반복문 쓰는 데 두려움이 있나봐. 아마 문제에 시간제한 0.5초인 거 보고 더더욱 반복문 쓰는 걸 고려 못한 듯.
>   특히 DP는 뭔가 돌아가면 안 될 것 같아서 바로바로 저장하면서 가는 방법을 찾으려고 한 것 같은데 일단 방법을 다 써봤어야 함.  
>   뭔가 공부할수록 점점 사고가 좁아지는 것 같아서 걱정이 된다,,,,아무것도 모르던 초반에 어케든 풀겠다고 아는 거 총동원해서 이것저것 시도해보던 때가 더 잘 풀린 듯
> - 그래도 이거 풀면서 Math.sqrt() 함수 처음 써봤다 ! 결과적으로 필요 없었지만 ㅋㅋ

```
package groupstudy.algorithm_lunchStudy;

import java.io.*;

public class BOJ17626_FourSquares {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());

        int[] square = new int[224];
        for (int i = 1; i < 224; i++) {
            square[i] = i * i;
        }

        // 냅다 하나씩 정리해주면
        int[] dp = new int[N+1];

        for(int i = 1; i <= N ; i++) {
            dp[i] = i;
        }

        for(int i = 1; i * i <= N ; i++) {
            int sqr = i*i;  /// 현재 제곱수
            for (int j = sqr ; j <= N ; j++) {
                dp[j] = Math.min(dp[j-sqr]+1, dp[j]);
            }
        }

        System.out.println(dp[N]);

    }
}

```
</details>

<details>
<summary> 자료구조 공부 (Deque) </summary>

> **_Deque, Priority Queue, Heap_**
</details>

<details>
<summary>SW역량검정시험 A형 화분 키우기 (성공)</summary>

> - 계속 뒤에 넘어갈 숫자들을 고려해서 현재를 정하려고 했는데, 어디서 넘어왔냐를 따져서 값을 정해야하는 거였음.
> - 진짜 제일 억울한 점은 전에 계단 문제 풀 땐가 비슷한 생각을 한 적이 있어ㅠㅠ 근데 이번엔 왜 생각을 못 해냈을까...ㅜㅜ  
>   계단 문제랑 비슷하게 풀면 되겠는데? 까지는 생각을 했는데 키포인트가 기억이 안 났어...진짜 바본가 봐봐...

```
import java.util.Scanner;

public class A_화분키우기 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();
        for (int Main = 1; Main <= T; Main++) {
            int N = sc.nextInt();
            int P = sc.nextInt();
            int[] fer1 = new int[N];
            int[] fer2 = new int[N];

            for (int i = 0; i < N; i++)
                fer1[i] = sc.nextInt();
            for (int i = 0; i < N; i++)
                fer2[i] = sc.nextInt();

            for(int i = 1 ; i < N ; i++) {
                fer1[i] = Math.max(fer1[i-1] + fer1[i] - P, fer2[i-1] + fer1[i]);
                fer2[i] = Math.max(fer2[i-1] + fer2[i] - P, fer1[i-1] + fer2[i]);
            }

            int ans = Math.max(fer1[N-1], fer2[N-1]);

            System.out.println(ans);

        }
    }
}

```
</details>

<br>

**2025.02.20 목요일**

<details>
<summary>SWEA1248. 공통조상</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA1248_%EA%B3%B5%ED%86%B5%EC%A1%B0%EC%83%81.java)
> **_Tree_**
>
> - 솔직히 트리 보고 겁부터 집어먹었다. 예전에 dfs와 bfs 풀 때 트리 구현에서 제대로 막혔던 기억이 있어서...  
>   어렴풋이 리스트로 구현해야한다는 건 알았는데 은연중에 부정하고 있다가,  
>   승언이가 그래프 구현에 LinkedList 많이 쓴다고 얘기해서 그제야 '아 역시 이 수 밖에 없나...'라고 얌전히 받아들임
> - 원래는 Node 클래스 만들어서 부모, 자식 정보 저장해서 쓰려고 했어...그게 더 간단할 것 같았는데 생각보다 구현하기가 까다로웠음
> - 트리 구조에 겁먹음 + Node 클래스로 복잡하게 구현하려 함 이슈로 한참 안 풀리다가 집 와서 LinkedList로 찬찬히 다시 푸니 겁 먹었던 거에 비해 수월하게 풀렸다.
> - 요즘 뭔가 '이렇게 풀면 되겠는데?'라고 생각하고 나서 자꾸 그 생각을 의심해서 문제가 잘 안 풀리는 것 같아. 일단 이것저것 해 보면 되는데 여러 번 실패할 에너지가 없는 것 같음.
> - BFS는 아직도 구현이 챡챡 안 된다. 거의 비슷하게 구현되는 부분이기도 하고 코드 보고 이해를 못하는 것도 아닌데 왜 자꾸 헷갈릴까. 걍 템플릿처럼 외우는 게 좋을 수도.
> - 최적화는 일단 풀고 나서 생각할 것!!!!!!! 그런 것까지 생각하면서 풀어내려갈 레벨 안 되는 거 알면서 왜 자꾸 욕심부릴까...?

```
package SWEA;

import java.util.*;

public class SWEA1248_공통조상 {

    static List<List<Integer>> tree;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for(int Main = 1 ; Main <= T ; Main++) {
            int V = sc.nextInt();   // 노드 개수
            int E = sc.nextInt();   //  간선 개수
            int sub1 = sc.nextInt();    // 공통조상 찾을 애 1
            int sub2 = sc.nextInt();    // 공통조상 찾을 애 2

            // 트리 만들어주기
            tree = new ArrayList<>();
            for(int i = 0 ; i < V+1; i++) {
                tree.add(new ArrayList<>());
            }
            for(int i = 0 ; i < E ; i++) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                tree.get(a).add(b);
            }

            // sub1 조상들 담아줄 배열
            List<Integer> parent1 = new ArrayList<>();
            findparent(parent1, sub1);
            // sub2 조상들 담아줄 배열
            List<Integer> parent2 = new ArrayList<>();
            findparent(parent2, sub2);

            // parent1이랑 parent2랑 비교하면서 같은 거 찾아줌
            int res = 999;
            for(int i = 0 ; i < parent1.size() ; i++) {
                if(parent2.contains(parent1.get(i))){
                    res = parent1.get(i);
                    break;
                }
            }

            // 음 이제 서브 트리 크기 세어줘야 해
            // res 기준으로...계속 타고 들어가면 될 듯? 자식 null 될 때까지
            System.out.printf("#%d %d %d", Main, res, cntChild(res, 1));
            System.out.println();
        }

    }

    // 타고 올라가면서 조상 노드들 찾아줄 메서드
    private static void findparent(List<Integer> parent, int sub) {
        for(int i = 0 ; i < tree.size() ; i ++) {
            if(tree.get(i).contains(sub)){
                parent.add(i);
                findparent(parent, i);
            }
        }
    }

    // 내려가면서 카운트 해줄 메서드
    private static int cntChild(int start, int cnt){
        Queue<Integer> queue = new LinkedList<>();
        queue.add(start);   //  3을 넣어
        while(!queue.isEmpty()) {
            int cur = queue.poll(); // 3을 꺼내서 cur로 정해줘

            if(tree.get(cur) != null) {
                for (int i = 0; i < tree.get(cur).size(); i++) {    // cur의 자식 노드들 넣어줘
                    queue.offer(tree.get(cur).get(i));
                    cnt++;
                }
            }
        }
        return cnt;
    }
}

```
</details>

<details>
<summary> BOJ1389. 케빈 베이컨의 6단계 법칙 </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/BOJ/BOJ1389_%EC%BC%80%EB%B9%88%EB%B2%A0%EC%9D%B4%EC%BB%A8%EC%9D%986%EB%8B%A8%EA%B3%84%EB%B2%95%EC%B9%99.java)
> **_BFS_**
>
> - 그래프 만들고, distance 배열 만들어서 탐색하면서 한 층 내려갈 때마다 그 깊이를 distance로 저장해준다
> - 접근 자체는 괜찮았던 것 같은데 구현에서 조금 꼬여서 챗gpt의 도움을 약간 받았다.
> - 접근법 다시 한 번 정돈해보고, 설계에서 구현까지 꼼꼼하게 다시 해볼 것 !
> - GPT가 알려준 최적화 방법
>   1. N <= 100 이므로 LinkedList 보다 이차원 배열로 푸는 편이 더 직관적임
>   2. depth 변수로 쓰지 말고 distance[i][cur] + 1 로 사용
>   3. vis[] 배열을 쓰지 말고 distance 배열을 제일 처음 -1로 초기화한 다음에, distance[i][e] == -1 조건으로 사용하는 게 더 간단함]

```
package workingon;

import java.io.*;
import java.util.*;

public class BOJ1389_케빈베이컨의6단계법칙 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        int N = Integer.parseInt(input[0]); // 노드의 수
        int M = Integer.parseInt(input[1]); // 간선의 수

        // graph 만들기
        List<List<Integer>> graph = new ArrayList<>();
        for(int  i = 0 ; i <= N ; i++) {
            graph.add(new ArrayList<>());
        }
        for(int i = 0 ; i < M ; i++){
            input = br.readLine().split(" ");
            int a = Integer.parseInt(input[0]);
            int b = Integer.parseInt(input[1]);
            graph.get(a).add(b);
            graph.get(b).add(a);
        }

//        System.out.println(graph);

        int[][] distance = new int[N+1][N+1];   // 거리 담아줄 배열. 행 숫자 ~ 각 열까지의 거리

        // 순서대로 bfs 돌려주면서 한 칸 내려갈 때마다 depth 늘려줄 거야
        for(int i = 1; i <= N ; i++) {
            int[] vis = new int[N+1];
            Queue<Integer> queue = new LinkedList<>();
            int depth = 1;
            queue.offer(i);
            vis[i] = 1;

            /// 이하 while 문 부분은 GPT 선생님의 도움을 받음
            while (!queue.isEmpty()) {
                int size = queue.size();    /// 이 부분이 추가 됨...
                for (int s = 0; s < size; s++) {
                    int cur = queue.poll();
                    for (int e : graph.get(cur)) {
                        if (vis[e] == 0) {
                            queue.offer(e);
                            vis[e] = 1; // 방문 체크
                            distance[i][e] = depth; // 거리 저장
                        }
                    }
                }
                depth++; // 한 레벨 끝나면 증가
            }

            // 원래 내 코드 (틀림)
//            while(!queue.isEmpty()){
//                for(int e : graph.get(queue.poll())) {
//                    if(vis[e] != 1) {
//                        queue.offer(e);
//                        vis[e] = 0;
//                        distance[i][e] = depth;
//                    }
//                }
//
//                depth++;
//            }

        }

        // 이제 행별로 합 구해서 min 구해줘
        int min = Integer.MAX_VALUE;
        int minidx = -1;
        for(int i= 1 ; i <= N ; i++ ) {
            int sum = 0;
            for(int j = 1; j <= N ; j++){
                sum += distance[i][j];
            }

            if(sum < min) {
                min = sum;
                minidx = i;
            }

            /// 같은 점수면 작은 값을 출력한다는 이 부분도 내가 놓쳤음..
            else if (sum == min && i < minidx) {
                minidx = i;
            }
        }

        System.out.println(minidx);

    }

}

```
</details>

<br>

**2025.02.21 금요일**

<details>
<summary>BOJ2609. 최대공약수와 최소공배수</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/BOJ/BOJ2609_%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98.java)
> **_유클리드 호제법_**
>
> - 트리 풀 때 부모들 따로 리스트에 저장해준 것처럼 이번에도 비슷하게 풀었는데 왠지 더 쉽게 푸는 방법 있을 것 같아서 찾아보니 유클리드 호제법이라는 게 있었다.
>   `GCD(a,b)=GCD(b,a mod b)`

```
// 이건 내가 푼 코드
import java.io.*;
import java.util.*;

public class BOJ.BOJ2338_긴자리계산 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        int a = Integer.parseInt(input[0]);
        int b = Integer.parseInt(input[1]);

        List<Integer> divisor1 = new ArrayList<>();
        for (int i = 1; i <= a; i++) {
            if (a % i == 0) divisor1.add(i);
        }

        List<Integer> divisor2 = new ArrayList<>();
        for (int i = 1; i <= b; i++) {
            if (b % i == 0) divisor2.add(i);
        }

        List<Integer> standard;
        List<Integer> theother;
        if (a > b) {
            standard = divisor2;
            theother = divisor1;
        } else {
            standard = divisor1;
            theother = divisor2;
        }

        int maxdiv = 0;

        for (Integer i : standard) {
            if (theother.contains(i)) {
                maxdiv = Math.max(maxdiv, i);
            }
        }

        System.out.println(maxdiv);
        System.out.println(a*b/maxdiv);
    }
}

```

</details>
<details>
<summary>BOJ1978. 소수 찾기</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/BOJ/BOJ1978_%EC%86%8C%EC%88%98%EC%B0%BE%EA%B8%B0.java)
> - 특정 숫자 이하의 소수를 모두 찾는 게 아니라, 특정 숫자의 소수 여부를 판별하는 거라서 에라토스테네스의 체는 못 썼다.
> - 첨엔 제일 단순하게 N-1까지의 모든 수로 나누어봤고, 그다음엔 Math.sqrt(N)까지만 나눠 봄.

```
package BOJ;

import java.io.*;
import java.util.ArrayList;

public class BOJ1978_소수찾기 {
    /**
     * 소수 찾기
     * <a href="https://www.acmicpc.net/problem/1978">...</a>
     */
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        String[] input = br.readLine().split(" ");
        int cnt = 0;
        for(int i = 0 ; i < N ; i++) {
            int num = Integer.parseInt(input[i]);
            boolean flag = false;
//            for(int j = 2; j < num ; j++) { // 2부터 num-1까지 보면서
            for(int j = 2; j <= Math.sqrt(num) ; j++) { // 2부터 num-1까지 보면서
                if(num % j == 0) {  // 하나라도 나눠지는 수가 있으면
                    flag = true;    // flag 바꿔주고
                    break;  // break
                }
            }
            if(!flag && num != 1) cnt ++; // 다 봤는데 없으면 cnt 올려줘
        }

        System.out.println(cnt);
    }
}

```
</details>

<details>
<summary>BOJ7785. 회사에 있는 사람</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_study/BOJ7785_%ED%9A%8C%EC%82%AC%EC%97%90%EC%9E%88%EB%8A%94%EC%82%AC%EB%9E%8C.java)
> **_HashMap_**
>
> - HashMap 순회 방법 공부함
> - 아까 현욱이가 얘기한 Collections.sort(리스트, Comparator) 등장
> - **ISSUE 1**  
>   처음에는 남아있는지 여부를 boolean 값으로 저장해줘야 하나 했는데
>   생각해보니 그거나 String 으로 그대로 저장해주는 거나 별반 다를 거 없어서 그냥 진행
> - **ISSUE 2**  
>   hashmap은 순서가 없다보니, 순회 방법이 좀 고민이었음.  
>   함수도 찾아보고 이것저것 해보다가 entryset 쓰는 방법 발견.  
>   이것 말고도 Iterator 나 keyset 쓰는 방법도 있다곤 하는데… 그건 다음에 보고...
> - **ISSUE 3**  
>   그리고 마지막에 정렬할 때 entryset 안에서 처리해주고 싶어서 고민했는데  
>   안 되는 것 같아서 그냥 ArrayList로 받아오는 한 단계 거쳐서 처리해줌

```
package groupstudy.algorithm_study;

import java.io.*;
import java.util.*;

public class BOJ7785_회사에있는사람 {
    /**
     * 회사에 있는 사람
     * <a href="https://www.acmicpc.net/problem/7785">...</a>
     */

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        HashMap<String, String> hashmap = new HashMap<>();
        StringBuilder sb = new StringBuilder();
        for(int i = 0 ; i < N ; i++) {
            String[] log = br.readLine().split(" ");
            String name = log[0];
            String inout = log[1];
            hashmap.put(name, inout);
        }   // 이 반복문 돌고 나면 모든 사람의 최종 상태만 남을 거야

        List<String> names = new ArrayList<>();

        for(Map.Entry<String, String> entry : hashmap.entrySet()){  // HashMap의 순회 방법
            if(entry.getValue().equals("enter")) {
                names.add(entry.getKey());
            }
        }

        // Collections.sort(names, Collections.reverseOrder()) 말고 이렇게도 쓸 수 있다
        names.sort(Collections.reverseOrder());         for(String name : names) {
            sb.append(name).append("\n");
        }

        System.out.println(sb);
    }
}

```
</details>

<br>

**2025.02.22 토요일**

<details>
<summary> SWEA2930. 힙 </summary>

[코드1](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA2930_%ED%9E%99.java)
[코드2](https://github.com/leeozzi/study/blob/master/APS/SWEA/SWEA2930_%ED%9E%99_2.java)
> **_Heap_**
>
> - 이해는 다 되는데 틀 없이 냅다 만들 수 있을 정도로 익숙하진 않은 느낌. 어려운 개념도 아닌데 이상하게 머리가 굳어있다.
> - 배열 크기 잘못 설정해서 런타임 에러로 몇 번 fail. 10의 5승까진데 잘못 봐서 10의 4승까지로 해놨었다...

```
// 배열로 만들기
package SWEA;

import java.util.*;

public class SWEA2930_힙 {

    static int[] heap;
    static int heapSize;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();

        for(int Main = 1; Main <= T ; Main++) {
            System.out.print("#" + Main + " ");
            heap = new int[100001];
            heapSize = 0;

            int N = sc.nextInt();
            for(int n = 1; n <= N ; n++) {
                int op = sc.nextInt();
                if(op == 1) {
                    push(sc.nextInt());
                } else if (op == 2) {
                    System.out.print(pop() + " ");
                }
            }

            System.out.println();
        }

    }

    public static void push(int x) {

        heap[++heapSize] = x;   // 일단 냅다 넣어주고

        // 부모랑 자식 인덱스 일단 뽑아놔
        int p = heapSize / 2;
        int ch = heapSize;

        // 이제 자리 찾아갈 거야 (올라감)
        while(p > 0 && heap[p] < heap[ch]){
            swap(p, ch);

            // 인덱스 바꿔줘야지
            ch = p;
            p = ch/2;   // 올라간 위치의 부모
        }
    }

    public static int pop() {
        if(heapSize == 0)
            return -1;

        int removed = heap[1];   // 제거할 루트
        heap[1] = heap[heapSize]; // 마지막 노드 올려주고
        heap[heapSize--] = 0;

        int p = 1;
        int ch = p * 2; // 왼쪽 노드
        if(ch+1 <= heapSize && heap[ch+1] > heap[ch])
            ch += 1;

        // 얘를 이제 내려줄 거야
        while(ch <= heapSize && heap[p] < heap[ch]){
            swap(p, ch);

            p = ch; // 내 인덱스 갱신
            ch = p * 2; // 내려간 자리의 자식

            if(ch+1 <= heapSize && heap[ch+1] > heap[ch])
                ch += 1;
        }

        return removed;
    }

    public static void swap(int idx1, int idx2) {
        int temp = heap[idx1];
        heap[idx1] = heap[idx2];
        heap[idx2] = temp;
    }
}

```

```
// pq 사용
package SWEA;

import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Scanner;

public class SWEA2930_힙_2 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        StringBuilder sb;
        int T = sc.nextInt();
        for(int Main = 1; Main <= T ; Main++) {
            PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());
            sb = new StringBuilder();
            sb.append("#").append(Main).append(" ");

            int N = sc.nextInt();
            for(int n = 0 ; n < N ; n++) {
                if(sc.nextInt() == 1){
                    pq.offer(sc.nextInt());
                } else {
                    if(!pq.isEmpty())
                        sb.append(pq.poll()).append(" ");
                    else
                        sb.append("-1 ");
                }
            }

            System.out.println(sb);
        }
    }
}

```
</details>

<details>
<summary>BO3273. 두 수의 합</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_study/BOJ3273_%EB%91%90%EC%88%98%EC%9D%98%ED%95%A9.java)
> **_투포인터_**
>
> - 투포인터 쓰면 되는 건 알았는데 괜히 다른 방식으로 풀어보고 싶어서 이것저것 도전하다가 오억번 틀림  
>   결국 시간초과를 해결하지 못하고 투포인터로 해결했다...
> - 근데 첨에 정렬 안 하고 썼다가 또 틀림 ㅋㅋ

```
package groupstudy.algorithm_study;

import java.io.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class BOJ3273_두수의합 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());    // 개수
        String[] arr = br.readLine().split(" ");   // 수열 입력
        List<Integer> list = new ArrayList<>(); // 수열
        for (int i = 0; i < n; i++) {
            list.add(Integer.parseInt(arr[i]));
        }

        Collections.sort(list);

        int x = Integer.parseInt(br.readLine());    // 최종 합

        int start = 0;
        int end = list.size() - 1;
        int cnt = 0;

        System.out.println(list);
        for (int i = start; i < list.size(); i++) {
            for (int j = end; j > i; j--) {
                System.out.println("현재 start 위치 : " + list.get(i) + " 현재 end 위치 : " + list.get(j));
                if (list.get(i) + list.get(j) == x) {
                    cnt++;
                    end = j;
                    System.out.println(list.get(i) + "+" + list.get(j));
                    break;
                }
            }
        }

        System.out.println(cnt);
    }
}

```

</details>

<details>
<summary> BOJ2805. 나무 자르기</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_study/BOJ2805_%EB%82%98%EB%AC%B4%EC%9E%90%EB%A5%B4%EA%B8%B0.java)
> - 숫자가 엄청 크면 이분탐색을 의심하라고 햇다...M 최대가 20억...높이 최대가 10억....? 혹시,,,,,,?
> - 근데 그 이분탐색을 어떻게 써야할지에 대해서 고민하다가 너무 꼬였다.
> - 첨에 생각했던 로직은
>
>   1.  잘라야 하는 길이의 범위를 찾는다.  
>        1-1) 나무들을 높은 순서로 정렬하고  
>        1-2) 나무들 간의 높이 차이를 이용해 각 높이만큼 잘랐을 때 얻을 수 있는 양을 구한다  
>        1-3) 그 양이 M보다 커지는 높이(maxidx)를 찾고, 구해야 하는 나무 길이 H의 범위를 maxidx의 높이와 maxidx-1의 높이 사이로 정한다
>   2.  그 범위 안에서 이분탐색하면서 정확한 높이를 찾아간다.
>
>   이거였는데 단계가 많아지니까 너무 헷갈림...
>   테케도 나와있는 건 두 개 밖에 없는데 세세한 조건들이 걸렸어
>
> - 알고 보니 그냥 단순한 매개변수탐색으로 하면 되는 문제였다. 저렇게 단계를 나눠줄 필요가 없었음. 입력 최대값 10억 20억인 거 보고 오히려 쓸데없이 많이 생각한 듯. 그냥 단순 매개변수탐색 한 번 시도는 해볼걸.
> - 밤새도록 고민하고 결국 챗GPT 도움 받은 게 넘 분하긴 한데 이거 매개변수수탐색 템플릿처럼 연습하기 좋아 보여. 잘 봐 둬야지.

```
package workingon;

import java.io.*;
import java.util.*;

public class BOJ2805_나무자르기 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken()); // 나무 개수
        int M = Integer.parseInt(st.nextToken()); // 필요한 나무 길이

        // 트리 배열 만들어주기
        st = new StringTokenizer(br.readLine());
        int[] arr = new int[N];
        int maxHeight = 0;
        for (int i = 0; i < N; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
            maxHeight = Math.max(maxHeight, arr[i]);
        }

        // 이분탐색
        int left = 0;
        int right = maxHeight;
        int res = 0;

        while (left <= right) {
            int mid = (left + right) / 2;
            long sum = 0;

            for (int i = 0; i < N; i++) {
                if (arr[i] > mid)
                    sum += (arr[i] - mid);
            }

            if (sum < M)
                right = mid - 1;

            else if (sum >= M) {
                res = mid;
                left = mid + 1;
            }
        }

        System.out.println(res);

    }
}
```
</details>

<br>

**2025.02.23 일요일**

<details>
<summary>BOJ1654. 랜선 자르기</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_study/BOJ1654_%EB%9E%9C%EC%84%A0%EC%9E%90%EB%A5%B4%EA%B8%B0.java)
> - 나무 자르기에 시달리고 난 후라서 이분탐색이 머리에 남아있었음 + 조건에 범위 2^31 - 1까지인 거 보고 이분탐색 생각하다가 일단 냅다 템플릿처럼 써봄.
> - 0으로 나눠지는 경우랑, long 써야하는 거 생각 못해서 몇 번 틀림..
>   0으로 나눠지는 경우는 진짜 도저히 못 찾겠어서 반례 찾아주는 사이트에 SOS 침.
> - Q. 근데 int 표현 범위가 2^31-1까진데 왜 long 써야 했던 거지?

```
package workingon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ1654_랜선자르기 {
    public static void main(String[] args) throws IOException {
        /* 입력 받기 */
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int K = Integer.parseInt(st.nextToken());   // 이미 가지고 있는 랜선의 개수
        int N = Integer.parseInt(st.nextToken());   // 필요한 랜선의 개수
        long[] arr = new long[K];
        long max = 0;
        for (int i = 0; i < K; i++) {
            String line = br.readLine();
            arr[i] = Integer.parseInt(line);
            max = Math.max(arr[i], max);
        }

        /* 이분 탐색 해줄 거야 */
        long left = 0;
        long right = max;
        long res = 0;

        while (left <= right) {
            long mid = (left + right) / 2;
//            System.out.println("left : " + left + " right : " + right + " mid : " + mid);

            // 자른 개수 봐야지
            int cut = 0;
            for (int i = 0; i < K; i++) {
                if(mid == 0)
                    mid = 1;
                    cut += (arr[i] / mid);
            }

            if (cut < N) {
                right = mid - 1;
            }

            if(cut >= N) {
                left = mid + 1;
                res = mid;
            }

        }

        System.out.println(res);


    }
}

```
</details>

<br>

**2025.02.24 월요일**

<details>
<summary> BOJ14719. 빗물 </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_lunchStudy/BOJ14719_%EB%B9%97%EB%AC%BC.java)
> - **_투포인터, stack_**
> - 골드의 벽...진짜 너무 어려웠다. 투포인터 써서 풀긴 했는데 스택으로 푸는 방법도 있었다. 스택 방법 찾아봤는데 진짜 너무 이해가 안 돼서 머리 터질 뻔했다. 결국 이해해내긴 함. 

```
// 투포인터 사용
import java.io.*;
import java.util.*;

public class BOJ.BOJ2338_긴자리계산 {
    public static void main(String[] args) throws IOException {
        /// 입력 받기
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int H = Integer.parseInt(st.nextToken());
        int W = Integer.parseInt(st.nextToken());
        int[] arr = new int[W];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < W; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        // 투포인터 만들기
        int left = 0;
        int right = arr.length - 1;
        int leftMax = arr[left];
        int rightMax = arr[arr.length-1];
        int cnt = 0;


        while (left < right) {
            if(arr[left] < arr[right]){
                left ++;
                if(arr[left] >= leftMax){
                    leftMax = arr[left];
                } else {
                    cnt += (leftMax - arr[left]);
                }
            }

            else {
                right --;
                if(arr[right] >= rightMax){
                    rightMax = arr[right];
                } else {
                    cnt += (rightMax - arr[right]);
                }
            }
        }

        System.out.println(cnt);
    }
}

```

```
// Stack 사용
package groupstudy.algorithm_lunchStudy;

import java.io.*;
import java.util.*;

public class BOJ14719_빗물 {
    /**
     * 빗물
     * <a href="http://acmicpc.net/problem/14719">...</a>
     */
    public static void main(String[] args) throws IOException {
        /// 입력 받기
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int H = Integer.parseInt(st.nextToken());
        int W = Integer.parseInt(st.nextToken());
        int[] arr = new int[W];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < W; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        // 투포인터 만들기
        int left = 0;
        int right = arr.length - 1;
        int leftMax = arr[left];
        int rightMax = arr[arr.length-1];
        int cnt = 0;

        while (left < right) {
            if(arr[left] < arr[right]){
                left ++;
                if(arr[left] >= leftMax){
                    leftMax = arr[left];
                } else {
                    cnt += (leftMax - arr[left]);
                }
            }

            else {
                right --;
                if(arr[right] >= rightMax){
                    rightMax = arr[right];
                } else {
                    cnt += (rightMax - arr[right]);
                }
            }
        }

        System.out.println(cnt);
    }
}

```
</details>

<br>

**2025.02.26 수요일**

<details> 
<summary>BOJ29160. 나의 FIFA 팀 가치는?</summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/groupstudy/algorithm_lunchStudy/BOJ29160_%EB%82%98%EC%9D%98FIFA%ED%8C%80%EA%B0%80%EC%B9%98%EB%8A%94.java)
> **_Priority Queue_**
>
> - 입력값 받기 실수 실화임..?ㅠㅠㅠㅠㅠㅠㅠ이거 못 찾아서 오천번 시도하고 결국 수인이가 알려줌....
> - PQ 쓰는 것만 떠올리면 논리 자체는 그렇게 어렵지 않은 문제였다.

```
import java.io.*;
import java.util.*;

public class BOJ.BOJ2338_긴자리계산 {
    /**
     * 나의 FIFA 팀 가치는?
     * <a href="https://www.acmicpc.net/problem/29160">...</a>
     */
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        int N = Integer.parseInt(input[0]);
        int K = Integer.parseInt(input[1]);

        List<PriorityQueue<Integer>> positions = new ArrayList<>();

        for(int i = 0 ; i < 12 ; i++) {
            positions.add(new PriorityQueue<>(Collections.reverseOrder()));
        }

        for(int i = 0 ; i < N ; i++) {
            input = br.readLine().split(" ");
            int P = Integer.parseInt(input[0]);
            int W = Integer.parseInt(input[1]);
            positions.get(P).offer(W);
        }

        // 3월 더해줘
        int[] selected = new int[12];
        for(int i = 0 ; i < 12 ; i++){
            if(!positions.get(i).isEmpty()) {
                selected[i] = positions.get(i).poll();
            }
        }

        while(K-- > 0) {
            // 8월 빼줘
            for (int i = 1; i < 12; i++) {
                positions.get(i).offer(Math.max(selected[i] - 1,0));
            }

            // 11월 다시 재구성
            for (int i = 1; i < 12; i++) {
                if (!positions.get(i).isEmpty()) {
                    selected[i] = positions.get(i).poll();
                }
            }
        }

        int sum = 0;
        for(int i = 1 ; i < 12 ; i++) {
            sum += selected[i];
        }

        System.out.println(sum);
    }
}

```
</details>

<br>

**2025.02.27 목요일**

<details>
<summary> BOJ31575. 도시와 비트코인 </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/BOJ/BOJ31575_%EB%8F%84%EC%8B%9C%EC%99%80%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8.java)
> **_BFS, DFS_**
>
> - 난 DFS로 풀었는데 BFS로 풀었어도 괜찮을 것 같다
> - visited 배열 안 썼더니 시간초과 떴다.  
>   왜지...? 어차피 오른쪽이랑 아래로만 갈 수 있어서 중복 방문할 일은 없는데.

```
package BOJ;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class BOJ31575_도시와비트코인 {
    /**
     * 도시와 비트코인
     * <a href="https://www.acmicpc.net/problem/31575">...</a>
     */

    static int[][] map;
    static boolean[][] visited;
    static boolean res;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        int N = Integer.parseInt(input[1]);
        int M = Integer.parseInt(input[0]);
        map = new int[N][M];
        visited = new boolean[N][M];
        for (int i = 0; i < N; i++) {
            input = br.readLine().split(" ");
            for (int j = 0; j < M; j++) {
                map[i][j] = Integer.parseInt(input[j]);
            }
        }
        // 입력 끝 //

        dfs(0, 0);
        visited[0][0] = true;
        if(res) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }

    public static void dfs(int i, int j) {
        if(i == map.length-1 && j == map[i].length-1) {
            res = true;
            return;
        }

        int[] dx = {0, 1};  // 동, 남
        int[] dy = {1, 0};

        for (int d = 0; d < 2; d++) {
            int nx = i + dx[d];
            int ny = j + dy[d];

            if (nx >= 0 && ny >= 0 && nx < map.length && ny < map[0].length) {
                if (!visited[nx][ny] && map[nx][ny] == 1) {
//                    stack.push(new int[]{nx, ny});
                    visited[nx][ny] = true;
                    dfs(nx, ny);
                }
            }
        }
    }
}

```
</details>

<br>

**2025.02.28 금요일**

<details>
<summary> BOJ1672. DNA 해독 </summary>

[코드](https://github.com/leeozzi/study/blob/master/APS/BOJ/BOJ1672_DNA%ED%95%B4%EB%8F%85.java)
> **_Stack_**
>
> - Stack 쓰는 거 바로 생각해냈었는데, 자꾸 메모리 초과 떠서 StringBuilder도 건드려보고 했는데  
>   원인은 dna 배열에 있었다. char[][]로 받았을 때랑 String[][]로 받았을 때랑 메모리 사용량이 거의 11배 가까이 차이 남

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Stack;

public class BOJ.BOJ2338_긴자리계산 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        char[][] dna = {
                {'A', 'C', 'A', 'G'},
                {'C', 'G', 'T', 'A'},
                {'A', 'T', 'C', 'G'},
                {'G', 'A', 'G', 'T'}
        };

        HashMap<Character, Integer> map = new HashMap<>();
        map.put('A', 0);
        map.put('G', 1);
        map.put('C', 2);
        map.put('T', 3);

        int n = Integer.parseInt(br.readLine());
        String line = br.readLine();

        Stack<Character> stack = new Stack<>();

        for(int i = 0 ; i < line.length() ; i++) {
            stack.push(line.charAt(i));
        }

        while(stack.size() > 1) {
            char b = stack.pop();
            char a = stack.pop();

            stack.push(dna[findidx(a)-1][findidx(b)-1]);
        }

        System.out.println(stack.pop());

    }

    private static int findidx(char c) {
        switch(c) {
            case 'A':
                return 1;
            case 'G':
                return 2;
            case 'C':
                return 3;
            case 'T':
                return 4;
        }

        return -1;
    }
}

```
</details>
