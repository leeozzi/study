
H가 점점 내려오면서 봐야겠는데
딱 떨어지지 않을 수도 있어... sum > M이 되는 H의 최소

H 최대 = 젤 높은 애 높이
H 최소 = 젤 낮은 애 높이    // => *수정) M 이 더 작을 수도 있음.
         // 높이가 막 10 20 30 12 28 이런데 M이 5일 수도 있어...그럼 26에서 잘라서 6 가져가야 함
         // 나무 간의 높이 차이가 중요할 듯!
            // 첫 번째로 높은 애랑 두 번째로 높은 애랑 차이 비교해서
                // diff >= M -> max - M;
                // diff < M -> diff += 두 번째로 높은 애랑 세 번째로 높은 애 차이 비교
            // 정렬해줘야겠다...
            // 정렬하면 30 28 20 12 10 (M = 5)
                // 처음에는 gap이 2니까 M보다 작아
                    // 일단 맨 위에 2만큼은 확실히 얻으니까, M -= 2
                    // 두 번째랑 세 번째 gap은 8 == 10 > M(==3) 이야
                        // 그럼 두 번째랑 세 번째 높이 사이에 H가 있겠군
                        // 두 번째 높이 - M 한 위치에서 잘라주면 될 듯 // => *수정) 아니야 첫 번째도 M만큼 더 잘리는 거잖아
-> 이 중간을 잘라서 sum 보고 up & down

sum > M 일 경우
    너무 많이 잘랐을지도 몰라
    근데 이게 최선일 수도 있음

sum < M 일 경우
    너무 적게 잘랐어
    좀 더 높여봐

sum == M 일 경우
    여기얏!



=================================

그...뭐야 쇠막대기 자르기처럼 겹친 거 처리해주는 부분이 필요할 듯


==================================

> 정렬해주고

> 범위 구하기
for(int i = 0 ; i < arr.size() ; i++)
    if(gapsum >= M) break;

    ** i+1번째가 있고,
    (i번째가 i+1번째랑)
    다른 높이일 때
        max = i번째
        min = i+1번째

    같은 높이일 때
        몇 개가 같은 높이인지를 구해줘
        끝까지 가면
            max는 직전에 높이 다른 애 or 만약 다 똑같으면 초기화값인 높이로 저장되겠지
            min을 1 낮추고

    ** i번째가 마지막 번호일 경우
        max = i번째
        min = 0

    gap = max - min
    gapsum += gap*layer

=> 이 반복문 돌고 나오면 max와 min 사이에서 끊어줘야 함.

==================================================


나무들 중에 중간값으로 자른 sum 저장해줘